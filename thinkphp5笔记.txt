

// think_web



一、PHP中get_object_vars()的用法。

    例子：

<!DOCTYPE html>
<html>
<body>

<?php
class Car
{
    var $color;
    function __construct($color="green") {
      $this->color = $color;
    }
    function what_color() {
      return $this->color;
    }
}

function print_vars($obj) {
   foreach (get_object_vars($obj) as $prop => $val) {
     echo "\t$prop = $val\n";
   }
}

// 实例一个对象
$herbie = new Car("white");

// 显示 herbie 属性
echo "\therbie: Properties\n";
print_vars($herbie);

?>  

</body>
</html>

输出结果： herbie: Properties color = white


解析1：

foreach (get_object_vars($obj) as $prop => $val) {
     echo "\t$prop = $val\n<br>";
   }

get_object_vars方法的作用是读取对象中$obj的变量名赋值给$prop,把变量值赋值给$val, 并且利用foreach遍历对象中所有的变量名和变量值

get_object_vars 作用就是将一个对象转化成一个关联数组（关联数组类似于json）


解析2：
 
function __construct($color="green") 

 这里的 $color="green 起到的是默认值的作用，当实例化对象为 $herbie = new Car(); 时， color值为green, 当实例化对象为 $herbie = new Car("white"); 时， color值为white.



================================================================================================================================

二、echo，print，print_r，var_dump 的区别

1.echo

输出一个或者多个字符串。

2.print

和 echo 一样，速度 比 echo 慢。
	
3.print_r

打印关于变量的易于理解的信息,如果给出的是 string、integer 或 float，将打印变量值本身。如果给出的是 array，将会按照一定格式显示键和元素。object 与数组类似。 记住，print_r() 将把数组的指针移到最后边。使用 reset() 可让指针回到开始处。

4.var_dump

此函数显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开值，通过缩进显示其结构。

5.var_dump 和 print_r 的区别

var_dump 返回表达式的类型与值而 print_r 仅返回结果，相比调试代码使用 var_dump 更便于阅读。


===========================================================================================================================================


三、foreach 循环

foreach ($array as $value)
{
    要执行代码;
}

每进行一次循环，当前数组元素的值就会被赋值给 $value 变量（数组指针会逐一地移动），在进行下一次循环时，您将看到数组中的下一个值。

<?php
$x=array("one","two","three");
foreach ($x as $value)
{
    echo $value . "<br>";
}
?>

===========================================================================================================================================

四、$_SERVER

   $_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目；服务器可能会忽略一些，或者提供一些没有在这里列举出来的项目。




五、composer 概念

         composer: 作曲家;调停人;设计者

         Composer 是 PHP5.3以上 的一个依赖管理工具。它允许你声明项目所依赖的代码库，它会在你的项目中为你安装他们。Composer 不是一个包管理器。是的，它涉及 "packages" 和 "libraries"，但它在每个项目的基础上进行管理，在你项目的某个目录中（例如 vendor）进行安装。默认情况下它不会在全局安装任何东西。因此，这仅仅是一个依赖管理。


===========================================================================================================================================
===========================================================================================================================================
===========================================================================================================================================
===========================================================================================================================================

-------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------


ThinkPHP5.1完全开发手册     
      https://www.kancloud.cn/manual/thinkphp5_1/353951


注意：

       慕课网用的是 thinkphp5.0

       我用的是 thinkphp5.1


 2-1 关于MVC (06:51)

       1、 MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。


       2、mvc分层模式是模型model、视图view、控制器controller，相互利用又互不相干。m主要是数据、v是界面（可改变URL，URL是相当于地址）、c是输入输出，无m的web开发，如“静态页面”

     
       3、框架和设计模式的区别

            有很多程序员往往把框架模式和设计模式混淆，认为MVC是一种设计模式。实际上它们完全是不同的概念。

            框架、设计模式这两个概念总容易被混淆，其实它们之间还是有区别的。框架通常是代码重用，而设计模式是设计重用，架构则介于两者之间，部分代码重用，部分设计重用，有时分析也可重用。在软件生产中有三种级别的重用：内部重用，即在同一应用中能公共使用的抽象块;代码重用，即将通用模块组合成库或工具集，以便在多个应用和领域都能使用；应用框架的重用，即为专用领域提供通用的或现成的基础结构，以获得最高级别的重用性。

            框架与设计模式虽然相似，但却有着根本的不同。设计模式是对在某种环境中反复出现的问题以及解决该问题的方案的描述，它比框架更抽象；框架可以用代码表示，也能直接执行或复用，而对模式而言只有实例才能用代码表示;设计模式是比框架更小的元素，一个框架中往往含有一个或多个设计模式，框架总是针对某一特定应用领域，但同一模式却可适用于各种应用。可以说，框架是软件，而设计模式是软件的知识。

           （1）、框架模式有哪些？

                     MVC、MTV、MVP、CBD、ORM等等；


           （2）、框架有哪些？

                    C++语言的QT、MFC、gtk，Java语言的SSH 、SSI，php语言的 smarty(MVC模式)，python语言的django(MTV模式)等等

 
           （3）、设计模式有哪些？

                    工厂模式、适配器模式、策略模式等等

            简而言之：框架是大智慧，用来对软件设计进行分工；设计模式是小技巧，对具体问题提出解决方案，以提高代码复用率，降低耦合度。


-------------------------------------------------------------------------------------------------------------------------------------------


 2-2 Thinkphp的安装 (15:36)

TP5开发环境：PHP>=5.4.0  mysql:5.0

thinkphp安装

1。用过git安装

     跳转要某个项目下，

      github网址： https://github.com/top-think   

      需要克隆 think 和 framework

      用git克隆： git clone --depth=1 https://github.com/top-think/think.git think_git

      --depth=1: 只克隆最新的代码


    通过git安装
    a.打开cmd命令行工具，切换需要放置thinkphp5安装的目录
    b.使用命令 #git clone --depth=1 git@gitgub.com:top-think/think.git  mythinkphp（depth=1表示安装最新的版本）
    c.安装完成，切换到mythinkphp安装的目录下，继续安装thinkphp系统框架，命令 #git 

    访问think_git目录下的public目录，有页面显示表示安装成功

    http://localhost/think_git/public/
    

2. 通过composer安装

      网址： www.phpcomposer.com


3. 通过Download官网安装

       网址： http://www.thinkphp.cn

            可以选择自己想要的版本。


-------------------------------------------------------------------------------------------------------------------------------------------


 2-3 Thinkphp目录介绍 (13:45)

|-application 应用目录（几乎整个项目的内容都写在这里）

	|-index（这里的文件夹tp5叫做模块-----一般是前台模块，也可以根据需要需求修改成其他（例如：home），需要修改配置文件，修改默认模块、控制器、操作）  【注】：TP5默认只有一个index文件（模块）和一个控制层（conrroller），我们在写代码的时候会自己新建一个model和view,这样就组成了这个Index模块儿的MVC(controller控制层，model模型层，view视图层),如需后台(一般来说都需要)，则需要新建一个后台模块(admin)
		|-controller(控制层)
		|-model(模型层)
		|-view(视图层)

	|-admin(后台模块)
		|-controller(控制层)
		|-model(模型层)
		|-view(视图层)

        |- command.php 是控制台的配置文件，当我们用命令行执行thinkphp的时候，它会读取command.php的配置


	|- common.php 它是项目的公共文件，当我们编写一些通用函数的时候，比如我们写一个函数，想在所有的模块儿中都能调用，那么我们就可以把函数写在改文件中，它就可以注册到全局，在任何地方都可以调用


	|- config.php 它是应用的配置文件，整个应用都读取这个配置，也就是admin模块儿和index模块儿会通用这个配置


	|- database.php 它是数据库配置文件，如果我们需要连接数据库，那么我们只需要修改database.php的配置就可以了


	|- route.php 它是路由文件，当我们想对URL进行美化，那么我们就可以修改此文件，对其增加一些路由配置，就可以达到美化的效果


        |- tags.php 它是应用行为扩展文件，在thinkphp中，它为我们埋下了很多钩子，我们可以对框架进行扩展，而不需要修改框架本身的源码，我们需要在某一个钩子上注册某些函数，或者是注册某些行为，来通过行为来改变框架的执行流程


|-extend  目录,这个目录是我们下载第三方库时候使用的，当然我们不是通过composer来下载的，比如说我们有一个第三方库，我们用着比较好用，但是它没有composer包，我们就可以将类库下载到extend目录，之后我们修改一下命名空间，就可以直接在我们的应用中使用

|-publiic 我们网站的根目录，也就是说我们网站根目录下所有的这些文件都是允许访问的

	|-static 主要用来放静态文件，比如说css,js,图片等等

	|-index.php 整个网站或整个应用的入口文件，所有的请求都会经过index.php之后再去转发

	|-router.php 它是框架快速启动的测试文件，比如你本地没有安装Apache，只安装了PHP，那么我们可以同过，PHP内置的workserver来启动，通过这个文件，我们就可以启动这个框架


|-runtime 它是网站运行中的缓存文件，它包括日志，缓存和编译文件等等。

|-thinkphp 它是框架文件,也就是说thinkphp5的框架都在里边

	|-lang 里边是语言包

	|-library 目录是框架的核心，它里边有think(它是整个框架的核心文件)和traits(它是类库的扩展)两个目录

		|-think Think 类库包目录

		|-traits 系统 Traits 目录

	|-tpl 是我们框架默认的一些模板（了解知识）

		|-default_index.tpl 它是我们自动生成的控制器模板文件


		|-dispatch_jump.tpl它是我们网站发出成功或失败的中间跳转文件


		|-page_trace.tpl它是我们调试时显示的模板文件


		|-think_exception.tpl它是我们抛出异常时页面展示的文件

	|-base.php 定义一些常量

	|-console.php 它是控制台的入口文件

	|-convention.php 是框架惯例配置文件

	|-help.php 助手函数

	|-start.php是框架启动文件

|-vendor 是composer安装过程中生成的目录，通过composer安装的所有类库都被安装在了这个目录中


-------------------------------------------------------------------------------------------------------------------------------------------


 2-4 模块设计 (13:46)

http://localhost/think_git/public/index/User/demo

解释：
      index 表示 index 模块

      User  表示 index 模块中 一个名为 User 的 controller 控制器

      demo  表示 调用User控制器中的一个名为demo的函数 


当只在地址栏输入 ‘http://localhost/think_git/public/’时，相当于 输入 'http://localhost/think_git/public/index/index/index'

新版框架默认不再支持改变应用目录（application）和入口文件位置，如果你需要更改，需要自己重新定义入口文件
下面是一个例子（把入口文件放到应用根目录，并且更改应用目录名称为app）：
      <?php

           namespace think;

           // 定义应用目录

           define('APP_PATH', __DIR__ . '/app/');

           // 加载框架基础引导文件

           require __DIR__ . '/thinkphp/base.php';

           // 添加额外的代码

           // ...

           // 执行应用并响应

           Container::get('app', [APP_PATH])->run()->send();

注意：

     出现common无法找到问题

         1.命名空间不对

         2.引用路径不对

         3.控制器下的php文件需要大写开头


    common模块不能直接用url访问:  当我们创建模块的时候，把模块命名为common这个名字的时候，不可以通过url直接访问这个模块，因为thinkPHP把common做成一个公共的模块，不允许我们在url上直接访问。但是我们可以通过其他模块来调用访问这个模块；至于通过其他模块怎么调用common模块

   common文件夹是公共模块目录，不可以直接访问

    调用common下的方法：

    use app\common\controller\Index as commonIndex;

    public function common(){

      $common = new commonIndex();

      return $common -> Index();

   }

    as commonIndex   是别名


=======================================

一，use 然后new

use app\common\User as commonUser;

        $commonUser=new commonUser();

        return $commonUser->showNames("aaaa");

二，use 然后extends commonUser;

        use app\common\User as commonUser;

        class index extends commonUser

    {        

            function index(){

                        return $this->showNames("bbbb");

            }

    }

三，app下common模块是公共的，前后台都可调用的，但url不可直接访问的。可以将公共的代码编写在app\common模块中，提高代码的复用性，减少代码的重复,而因为common不能直接访问，所以比较安全

=========================================

四、在app\index模块中的index控制器使用到app\common\中Index类的例子：

					<?php
					namespace app\index\controller;

					use app\common\controller\Index as commonIndex; 

					class Index {

						public function index(){

							return  "this is index index index";
						}

						public function common(){

					          $common = new commonIndex();
					          return "index_common: ". $common->index();
							//return "this is index index common";
						}
					}

-------------------------------------------------------------------------------------------------------------------------------------------


 2-5 惯例配置 (04:56)

       convention： 惯例，习俗，规矩，会议;全体与会者;国际公约;

       框架的设计者为我们提前设计好了框架必须的配置，我们只有拥有这些配置才能正常的使用框架，这些配置位于位于thinkphp目录下的convention.php，这些就是框架的惯例配置(即通常的配置)，我们可以修改惯例配置，来达到我们配置的目的；

       dump(config());  返回 convention.php 中的所有配置

       类名和类的文件名一样 比如 这里的类名是Index 那么类的文件名也必须是 Index



//1.定义配置文件目录（入口文件）  public目录下的 index.php 文件

                    define('CONF_PATH' , __DIR__ . '/../conf/');


//2.在与application同级目录下创建conf目录和conf目录下的config.php文件
 
   ----> 这里要注意的是： 现在的thinkphp5.1版本 和 教程里面所用的版本thinkphp5.0版本有点不同


    注意： 虽然我们可以就惯例配置convention.php来达到我们的配置，但是一般我们不能随意修改惯例配置convention.php
        

-------------------------------------------------------------------------------------------------------------------------------------------
 

2-6 应用配置 (05:44)

     应用配置 > 惯例配置， 惯例配置不能随意修改，所有通过修改应用配置，来覆盖惯例配置。

      我们的惯例配置是在位于thinkphp目录下的convention.php中，但在项目开发中,thinkphp文件夹下的框架文件不可以做任何修改,否则在后期升级维护的时候会带来许多的不便;

      惯例配置是框架内自带的配置;所以不能轻易修改convention.php文件。

应用配置

  1.通常我们如果想修改惯例配置中的参数不能直接修改在框架文件中修改，不利于框架的升级

  2.所有我们需要将应用的配置存放在自创建的conf目录下的config.php文件中，直接通过return []，来改变惯例配置参数

  3.实现原理主要用到 array_merge()方法，将两个数组合并，顺序靠后的数组中的同属性，

数组合并：
  
  array_merge();键名相同后面覆盖前面
  
  array_merge_recursive();键名相同，键值合并


      慕课网用的版本中修改配置： 

          新建一个跟app同级的conf文件夹，在下一层新建一个config.php文件，问文件里的代码为<?php     return [ 'app_email' =>'111111' ]; config.php中的配置会和convention.php中的配置合并。当配置有重复的时候，config.php中的配置会覆盖convention.php中的配置

          在入口文件index.php中添加define('CONF_PATH', __DIR__ . '/../conf/')，程序就会知道你的配置文件目录在根目录下的conf文件夹下了

          通过config.php可以修改惯例配置来为我们服务(因为惯例配置是框架自带文件,不建议修改),修改方法:如:return['app_debug'=>'ture','app_name'=>'nihao'];

          原理是用到了array_merge()数组函数; 

          只要在入口文件中定义了配置目录，目录名没有关系的！
          注意这个定义是配置目录和app同级，不要放在app里面，只要配置目录路径和实际位置相符，就不会错的

          // 定义配置文件目录xxxxx和应用目录同级

                   define('CONF_PATH', __DIR__.'/../xxxxx/');

          // 定义应用目录

                   define('APP_PATH', __DIR__ . '/../application/');


      我现在用的版本：

          在这个版本的目录下有一个config文件夹 里面的app.php就是应用设置，修改里面的内容可以直接覆盖think下的convention.php里的设置 不用在新建一个conf。
                 
    
      另一个版本：

          （1）
             没有config文件夹了，直接在app\config.php文件中修改相关配置，

             thinkphp/convention.php=>惯例配置（全局有效）；

             application/config.php=>应用配置（应用内生效，优先级>惯例配置）；

             extra/***.php=>扩展配置（不改变模块配置，配置文件名作为配置数组的键，返回值作为数组的值，相当于把一组配置打包，如无需打包要求不建议采用，可直接在应用配置中添加）；

             index/config.php=>专属配置，只在所在的的模块中生效优先级top。


          （2）版本更新了，没有config文件夹了，直接在app\config.php文件中修改相关配置，如果需要增加扩展配置，也是在app\extra ； 如果想在不同模块里使用不同的配置，比如在index模块下单独增加config，只需要在app\index 下新建config.php文件就可以了



-------------------------------------------------------------------------------------------------------------------------------------------

 2-7 扩展配置 (07:43)

      优先级： 扩展配置 > 应用配置  >  惯例配置

      扩展配置会覆盖应用配置

      在我们的开发中，配置项会很多，缓存,session,cookie配置，这些配置如果都在一个文件中，会很大，不容易维护，所以扩展配置诞生了
        
   
      慕课网的版本：

             与app同级目录下有一个conf文件夹，

             conf―config.php文件保存的是应用配置，config.php中返回的是一个配置数组，该数组会与tp的惯例配置数组进行array_merge（惯例配置指的是thinkphp文件夹下的convention文件中保存的所有配置）

             conf―extra文件夹，该文件夹下保存的PHP文件是扩展配置，配置之间的修改都是通过array_merge来实现的。

                      注意： 在conf文件夹下创建extra文件夹时，必须命名为‘extra’才能生效为扩展配置

             conf->extra->email.php 默认把文件名email当作配置项的key

                     问：email.php文件名怎么不用首字母大写？
                                  
                     答：因为emil.php在这个视频教程里不是一个类文件
 

             扩展配置优先级>应用配置
             <?php

             	return [
		             'host' => '96173@qq.com',
		             'name' => 'zoro1'
	             ];
             输出：
               ["email"] => array(2) {
                 ["host"] => string(12) "96173@qq.com"
                 ["name"] => string(5) "zoro1"
               }


       注意：
             在开发过程中，我
             
                extra->扩展配置

                config.php->应用配置

                database.php->数据库的默认配置

                extra里面的database.php为扩展配置可以替换掉数据库的默认配置convention下的database

                database.php也可以跟extra同级目录，而且可以替换掉应用配置config.php里面的database

                优先级：扩展配置>应用配置>默认配置


       我用的版本：

                 因为原本就在application的同级目录下有一个config目录,想扩展配置，直接在config目录下创建 xxx.php 文件即可。

                 例如： email.php,默认把文件名email当作配置项的key, 输出结果与上面的版本类似
                 <?php

             	    return [
		             'host' => '96173@qq.com',
		             'name' => 'zoro1'
	               ];
                 输出：
                    ["email"] => array(2) {
                    ["host"] => string(12) "96173@qq.com"
                    ["name"] => string(5) "zoro1"
                  }


  ===============================================================================

      


-------------------------------------------------------------------------------------------------------------------------------------------


 2-8 场景配置 (05:24)
   

为什么config里面的app_status能直接联系到home.php和office.php？

     系统已经写好了方法，设置"app_status" => "value",会指向value.php,所以能联系上home.php 和 office.php


场景配置

  1.为什么需要场景配置：不同的开发环境可能有一些配置不同，例如在家开发项目和在公司开发项目用的不是同一台电脑，那么这两台电脑上安装的数据库软件的密码可能就不同，在环境切换过程中不可能将不同的配置一一做更改,这样太麻烦

  2.如何实现场景配置：

    慕课网的版本 5.0:

          a.tp5提供了一个惯例参数app_status，只需要改变它的值就能实现一键修改平滑的切换运行环境

          b.app_status惯例参数对应的值表示应用哪个运行环境配置文件，该文件的文件名即为该参数的值，文件中的配置参数即为目前所需环境的参数配置

             步骤:

               （1）、在conf文件夹下的config.php应用配置文件里设置数组‘app_status’=>'home'或'office',来控制切换场景,

               （2）、再在conf文件夹下创建 home.php或office.php两个文件;在这两个文件里进行相应的配置就行了;切换办公环境的时候,直接修改config.php应用配置文件里的数组‘app_status’的值为'home'或'office'就行了;

               （3）、场景配置：  当config.php文件中的 'app_status' => 'home' 时，会读取这个配置文件home.php

                      场景配置：  当config.php文件中的 'app_status' => 'office' 时，会读取这个配置文件office.php 



	        注意：
                      如果使用场景配置(即home.php或office.php)修改数据库配置，则需要把数据库配置的所有项都写上，原来的数据库参数会被现有数据库参数全部替换，而不是替换不同项！修改其他配置也一样，如果这个配置是个数组,则需要把每一项都拷贝到场景配置文件里

             database配置，使用场景配置，需在每个配置文件中将database所有配置项进行设置，（即使不变）



   我用的版本5.1：

         好像没有场景配置，百度不到...

         
-------------------------------------------------------------------------------------------------------------------------------------------

 2-9 模块配置 (04:02)

     模块配置：专门为单个模块提供配置服务,之前的扩展配置和场景配置都是相对整个项目应用级别的，而模块配置是相对模块级别，作用域不同

       慕课网的版本 5.0:

           在conf文件夹下新建文件夹，文件夹的名字和相应的模块名字必须一致，例如在conf文件夹下新建文件夹的名为index，则这个文件夹下的所有配置只对index这个模块生效;

           1.在conf目录下index文件夹下新建config.php文件来进行对单个模块的配置进行设置,注意这个文件名必须为config.php;

           2.conf目录下index文件夹下也可以通过创建extra目录来扩展配置;

                |conf配置的作用域是整个项目应用

                |模块配置作用域只对相应单个模块生效;

           conf里面配置的作用域所有模块都有效

           conf下面Index或者Admini里面也可以有extra文件,conf\Index文件夹或者conf\Index文件夹中文件里面必须是config.php文件

           conf\Index(admin)\config.php里面的配置文件作用域仅限Index(admin)模块内


       我用的版本5.1：

为更好的应对模块化的开发要求，5.1的应用配置主要包括应用配置目录和模块配置目录，结构如下：

├─config（应用配置目录）
│  ├─app.php            应用配置
│  ├─cache.php          缓存配置
│  ├─cookie.php         Cookie配置
│  ├─database.php       数据库配置
│  ├─log.php            日志配置
│  ├─session.php        Session配置
│  ├─template.php       模板引擎配置
│  ├─trace.php          Trace配置
│  └─ ...               更多配置文件
│  
├─route（路由目录）
│  ├─route.php          路由定义文件
│  └─ ...               更多路由定义文件
│  
├─application （应用目录）
│  └─module （模块目录）
│     └─config（模块配置目录）
│     	 ├─app.php            应用配置
│     	 ├─cache.php          缓存配置
│     	 ├─cookie.php         Cookie配置
│     	 ├─database.php       数据库配置
│     	 ├─log.php            日志配置
│     	 ├─session.php        Session配置
│     	 ├─template.php       模板引擎配置
│     	 ├─trace.php          Trace配置
│  	 └─ ...               更多配置文件
│  


如果你需要统一管理所有的配置文件，那么可以把模块目录下面的config目录移动到应用配置目录下面改为模块子目录的方式，调整后的配置目录的结构如下：

├─application（应用目录）
├─config（配置目录）
│  ├─module （模块配置目录）
│  │  ├─database.php    数据库配置
│  │  ├─cache           缓存配置
│  │  └─ ...            
│  │
│  ├─app.php            应用配置
│  ├─cache.php          缓存配置
│  ├─cookie.php         Cookie配置
│  ├─database.php       数据库配置
│  ├─log.php            日志配置
│  ├─session.php        Session配置
│  ├─template.php       模板引擎配置
│  └─trace.php          Trace配置
│  
├─route（路由配置目录）
│  ├─route.php          路由定义文件
│  └─ ...               更多路由定义文件
一旦模块目录下面存在config目录，则应用配置目录下的模块配置则无效，也不会对两个目录的配置进行合并。



-------------------------------------------------------------------------------------------------------------------------------------------

 2-10 动态配置 (02:35)

         用dump是因为这是一个thinkPHP自定义的函数，php中原本是没有这个的，和var_dump本质上没什么区别，不过打印出来网页上显示dump比较整洁

         总结

         优先级：动态配置>模块配置>扩展配置>应用配置>惯例配置

         知识拓展以下仅供了解：

            1.惯例配置的作用域是全局，作用域越大，优先级越低；

            2.场景配置是用来切换开发场景的

            3.模块配置里也可细分扩展配置，很少用到，除非项目很庞大

            4.动态配置里有又可细分为控制器配置和方法配置(方法配置优先级>控制器配置)

            5.database.php属于扩展配置，但可直接放在conf目录下，也可放扩展(extra)目录下

动态配置
  1.何为动态配置：其实可以理解为控制器级别及以下级别的配置,例如只想作用于某个函数的配置。

  2.如何实现动态配置
    
         a.在某个控制器中的__construct()方法中使用config('name', 'david')，那么在该控制器中所有的方法都可以通过config()函数获取到配置的参数值
    
         b.在某个控制器方法中使用上述操作，那么配置的参数值，仅在该方法中生效
  
代码案例：

动态配置
|<?php
    namespace app\index\controller;
   
    class Index{   
                public function __construct(){    

                  config('before','beforeAction');//对当前控制器有效   在其他函数执行前，都会先执行这个函数。  这就是动态配置
        
                }
         
                public function demo(){

                    config('demoAction','demo'); //只对当前demo方法有效   这也是动态配置
                    dump(config());
               
                }
        
                public function index(){

                    config('indexAction','index');//只对当前index方法有效  这也是动态配置
                     dump(config());
       
                }
    
     }

    __construct() 是构造函数， 在其他函数执行前，都会先执行这个函数。



在某个方法中进行动态配置时（ 助手函数：config（‘配置参数’，‘配置值’）；），该动态配置只在该方法中生效，批量配置：

use think\Config ;//引入Config
Config::set([
'配置参数1'=>'配置值',
'配置参数2'=>'配置值'
]); 
// 或者使用助手函数
 config([
'配置参数1'=>'配置值',
'配置参数2'=>'配置值'
]);



ThinkPHP5.1完全开发手册：

配置获取

要使用Config类，首先需要在你的类文件中引入

          use think\facade\Config;

          或者（因为系统做了类库别名，其实就是调用think\facade\Config）

          use Config;

然后就可以使用下面的方法读取某个配置参数的值：

            echo Config::get('配置参数1');

如果你需要读取某个一级配置的所有配置参数，可以使用

            Config::pull('app');

            或者使用

            Config::get('app.');

读取所有的配置参数：

            dump(Config::get());

判断是否存在某个设置参数：

            Config::has('配置参数2');

助手函数
            系统定义了一个助手函数config，以上可以简化为：

                               echo config('配置参数1');

5.1的配置参数全部采用二级配置的方式（默认一级配置为app），所以当你使用config('name')的时候其实相当于使用：

                            config('app.name')

        支持获取多级配置参数值，直接使用（必须从一级开始写）

                                     config('app.name1.name2')

获取某个一级配置的所有参数可以使用

                                   config('app.');
读取所有的配置参数：

                                    dump(config());

或者你需要判断是否存在某个设置参数：

                                   config('?配置参数2');

动态设置

在控制器或者行为里面可以使用set方法或者助手函数动态设置参数（不过需要注意的是，动态设置生效的前提是该参数尚未被使用），格式：

                     Config::set('配置文件名.配置参数','配置值');

                     // 或者使用助手函数

                     config('配置文件名.配置参数','配置值');

动态设置的参数，最多支持二级，例如：

                     Config::set('app_trace', true);
            
               // 没有指定配置文件名的话 等效于下面的方式

                     Config::set('app.app_trace', true);

               // 助手函数的方式

                     config('app_trace', true);

                  也可以传入数组批量设置，并在第二个参数传入一级配置名，例如：

                                  Config::set([
                                      'app_trace'=>true,
                                      'show_error_msg'=>true
                                  ], 'app');

              // 或者使用助手函数

                                  config([
                                      'app_trace'=>true,
                                      'show_error_msg'=>true
                                  ],'app');



-------------------------------------------------------------------------------------------------------------------------------------------



 2-11 config类和config助手函数 (12:36)


需要注意版本：

我的也是ThinkPHP5.1版本的，视频教程是很久之前的那时候讲师应该也没有料到更新到ThinkPHP5.1会多一个Facade类吧，其实你可以试下：

针对第二个问题：（参考网址http://www.php.cn/manual/view/32828.html,ThinkPHP5.1新规定命名空间相关）

特别注意的是，如果你需要调用PHP内置的类库，或者第三方没有使用命名空间的类库，记得在实例化类库的时候加上 \，例如：

// 错误的用法
$class = new stdClass();
$xml  =  new SimpleXmlElement($xmlstr);
// 正确的用法
$class = new \stdClass();
$xml  =  new \SimpleXmlElement($xmlstr);
针对第一个问题：

（参考网址http://www.php.cn/manual/view/32819.html,ThinkPHP5.1配置基础相关）

（参考网址http://www.php.cn/manual/view/32830.html,ThinkPHP5.1核心Facade类库相关）

要使用Config类，首先需要在你的类文件中引入

use think\facade\Config;
或者（因为系统做了类库别名，其实就是调用think\facade\Config）

use Config;
(同样的要使用Env类，必须先引入think\facade\Env或者\Env。)

其实你第一个问题引入类名引入有问题，应该是think\facade\Config,facade类是TP5.1新规定,

门面（Facade）为容器中的类提供了一个静态调用接口，相比于传统的静态方法调用， 带来了更好的可测试性和扩展性，你可以为任何的非静态类库定义一个facade类。

=======================================================

慕课网的版本 5.0:



config类和助手函数config();主要功能获取和设置配置的两种方法

tp5的全局config()函数;

  1.实现的原理

    a.config()函数的所有功能来源于thinkphp框架目录下library目录下的think目录下的config.php类提供的方法

    b.通过thinkphp框架目录下的helper.php文件定义了一个全局的function config()方法，根据传参调用config.php类中不同的方法实现不同的功能，注意Config是首字母大写,因为tp5中所有类首字母都是大写

  2.config()函数的使用

    a.可以在项目任何地方调用

    b.因为不能确保在helper.php文件定义全局function config()方法之前是否已经定义了，所以在项目中建议使用config.php中的类方法操作整个框架的配置参数

    c.项目文件中通过 use think\config 引入类方法，因为是静态类，所以通过 Config::get() 可以获取所有配置的参数

	

    获取配置参数的值:Config::get('key');    等价于   config('key');

    设置配置参数的值:Config::set('key', 'value');   等价于   config('key', 'value');

    设置配置参数的作用域:Config::set('key', 'value', '作用域');   等价于   config('key','value','作用域');

    检测配置参数是否存在:Config::has('key');  等价于   config('?key');

    注意:参数不存在或者值为null,var_dump时都返回false;例:key=null; $a=Config::has('key'); var_dump($a);则返回false;
	

	设置配置时，注意所设置的配置的服务作用域;

	例:Config::set('key', 'value', 'index');设置配置的作用域是服务index模块的,那么获取的时候也要加上作用域

	Config::get('key','index');




   实例：
	// $res = Config::get();  //获取全部的配置参数
	// $res = config();       //config助手  获取全部的配置参数

        //    $res = Config::get('app_namespace');  //获取‘app_namespace’这个配置的值
        //    $res = config('app_namespace');       //使用config助手  也是获取‘app_namespace’这个配置的值

        //    Config::set('usernames','arvin');     //设置‘username’这个配置的值
        //    config('usernames', 'arvin');         //使用config助手  也是设置‘username’这个配置的值
 
        //    Config::set('usernames','arvin','index');  //设置‘username’这个配置的值，但这个值仅在index作用域下有效
        //    config('username', 'index_config', 'index'); //使用config助手  也是设置‘username’这个配置的值，但这个值仅在index作用域下有效

        // $res = Config::has('username');  //判断是否存在‘username’这个配置
        // $res = config('?username');      //使用config助手 也是判断是否存在‘username’这个配置

====================================================================


我用的版本5.1：



ThinkPHP5.1完全开发手册：


配置获取

要使用Config类，首先需要在你的类文件中引入

          use think\facade\Config;

          或者（因为系统做了类库别名，其实就是调用think\facade\Config）

          use Config;

然后就可以使用下面的方法读取某个配置参数的值：

            echo Config::get('配置参数1');

如果你需要读取某个一级配置的所有配置参数，可以使用

            Config::pull('app');

            或者使用

            Config::get('app.');

读取所有的配置参数：

            dump(Config::get());

判断是否存在某个设置参数：

            Config::has('配置参数2');

助手函数
            系统定义了一个助手函数config，以上可以简化为：

                               echo config('配置参数1');

5.1的配置参数全部采用二级配置的方式（默认一级配置为app），所以当你使用config('name')的时候其实相当于使用：

                            config('app.name')

        支持获取多级配置参数值，直接使用（必须从一级开始写）

                                     config('app.name1.name2')

获取某个一级配置的所有参数可以使用

                                   config('app.');
读取所有的配置参数：

                                    dump(config());

或者你需要判断是否存在某个设置参数：

                                   config('?配置参数2');

动态设置

在控制器或者行为里面可以使用set方法或者助手函数动态设置参数（不过需要注意的是，动态设置生效的前提是该参数尚未被使用），格式：

                     Config::set('配置文件名.配置参数','配置值');

                     // 或者使用助手函数

                     config('配置文件名.配置参数','配置值');

动态设置的参数，最多支持二级，例如：

                     Config::set('app_trace', true);
            
               // 没有指定配置文件名的话 等效于下面的方式

                     Config::set('app.app_trace', true);

               // 助手函数的方式

                     config('app_trace', true);

                  也可以传入数组批量设置，并在第二个参数传入一级配置名，例如：

                                  Config::set([
                                      'app_trace'=>true,
                                      'show_error_msg'=>true
                                  ], 'app');

              // 或者使用助手函数

                                  config([
                                      'app_trace'=>true,
                                      'show_error_msg'=>true
                                  ],'app');



-------------------------------------------------------------------------------------------------------------------------------------------

 2-12 环境变量的配置和使用 (17:51)

慕课网的版本 5.0:


1.什么是环境变量

tp除了加载项目配置config.php，还会去加载一个可能存在的 env.php ，位于项目根目录下，也就是跟composer.json同级。  

                 //.env文件可以自己创建
      

有点类似于场景配置,就是说在不同的情况下,项目对配置的要求会有所不同,比如项目的开发环境、预上线环境、测试环境、生产环境等等对配置的要求都不同;这个时候我们就要切换到相应的配置;


  例子：
        当我们在.env文件中内容为

                   email = 1095654363@qq.com

        我们在index.php文件中打印结果：
        
                  //dump($_ENV);

        输出结果为：
                     .....

                     ["PHP_EMAIL"] => string(17) "1095654362@qq.com"  //系统会自动给参数名添加前缀‘PHP_’，而大写.

                 

	       //dump($_ENV["PHP_EMAIL"]);  //用这个方法取值，如果我们没有提前配置好‘PHP_EMAIL’的值，程序会报错
               $res = Env::get('email');    //用这个方法取值，如果我们没有提前配置好‘PHP_EMAIL’的值，程序会返回null
               $res = Env::get('email_name','default'); //当‘email_name’为null时,默认赋‘default’值



2.方法步骤：

     a.在和app文件夹同级目录下,新建".env"或者env.php这个文件;

      env.php格式和配置文件一样，返回一个数组，例如：

             <?php

            return [

            'app_debug' =>false

                   ];

             ?>

	如果是新建的文件格式是.env,里面就不用<?php?>标识符了;直接书写  'app_debug' =>false这样就行;

	通过以上方式就算是初步把env配置设置好了,下面步骤就是开始使用env里面的配置了;

	b.接下来我们要掌握怎么获取到.env文件里面的配置了;

	例:我们在.env文件里书写了status=dev，接下来我们在conf文件下的config.php里面来获取这个设置：

	在config.php文件里与环境变量相关的都从.env配置文件中获取值

<?php

use think\Env;//注意这里别忘了写

return [

//tp5提供了一个惯例参数app_status，只需要改变它的值就能实现一键切换运行环境

'app_status' => Env::get('status','dev');

];

使用Env::get()方法获取配置的参数值;(或者$_ENV['a'])对于组参数需要这样使用Env::get(database.user);

同时系统也会自带环境变量;查看所有环境变量的方式dump($_ENV);



3、在.env文件中，以下两种配置效果是一样的：

                       ①、
                           [database]
                           hostname=localhost
                           username=root
                           password=root

                       ②、
                           database_hostname = localhost
                           database_username = root
                           database_password = root



               以上两种的打印结果都为：
                                       ["PHP_DATABASE_HOSTNAME"] => string(9) "localhost"
                                       ["PHP_DATABASE_USERNAME"] => string(4) "root"
                                       ["PHP_DATABASE_PASSWORD"] => string(4) "root"


4、在.env文件中配置 status=dev

     例子：

（1）.env文件中:

           status = dev


（2）在应用配置文件conf\config.php中：

      //利用.env环境配置 搭配场景配置
      return[
 
          'app_status' => Env::get('status','dev') //当没有为‘app_status’配置值时，默认赋值‘dev’
      ]

 (3)创建conf\dev.php文件和conf\test.php (注意：这里的dev.php文件和test.php文件相当于两种状态的切换，我们也可以再创建第三种状态类似prod.php)

 (4)当.env文件中：

          status = dev :  系统会读取 conf\dev.php中的配置

          status = test :  系统会读取 conf\test.php中的配置



5..env优先级:高于config.php;就是说.env里的设置会覆盖config.php里的配置;



==========================================================================================

      为什么dump($_ENV)输出一个空数组？

           $_ENV会为空，其原因通常是php的配置文件php.ini的配置项为：variables_order = "GPCS"。

            要想让$_ENV的值不为空，那么variables_order的值应该加上一个大写字母“E”，即：variables_order = "EGPCS"。


    没显示系统环境变量的

          打开php.ini，找到这样几行代码：

                   ; variables_order
                   ;Default Value: "EGPCS"
                   ; Development Value: "GPCS"
                   ; Production Value: "GPCS"

          然后，将;Default Value: "EGPCS"前面的分号去掉，整个配置变成：

                   ; variables_order
                   Default Value: "EGPCS"
                   ; Development Value: "GPCS"
                   ; Production Value: "GPCS"

          然后重启Apache就可以了。

========================================================================================


我用的版本5.1：

  环境变量定义

      可以在应用的根目录下定义一个特殊的.env环境变量文件，用于在开发过程中模拟环境变量配置（该文件建议在服务器部署的时候忽略），.env文件中的配置参数定义格式采用ini方式，例如：

                                           APP_DEBUG =  true

                                           APP_TRACE =  true


如果你的部署环境单独配置了环境变量（ 环境变量的前缀使用PHP_），那么请删除.env配置文件，避免冲突。

环境变量配置的参数会全部转换为大写，值为 null，no 和 false 等效于 ""，值为 yes 和 true 等效于 "1"。

注意，环境变量不支持数组参数，如果需要使用数组参数可以，使用下划线分割定义配置参数名：

                                  DATABASE_USERNAME =  root
                                  DATABASE_PASSWORD =  123456

获取环境变量的值使用下面的方式：

                                  Env::get('database_username');
                                  Env::get('database_password');

如果使用

                                  [DATABASE]
                                  USERNAME =  root
                                  PASSWORD =  123456


获取环境变量的值可以使用下面的方式获取：

                                  Env::get('database.username');
                                  Env::get('database.password');



注意注意：
          要使用Env类，必须先引入think\facade\Env或者\Env。


环境变量的获取不区分大小写

可以支持默认值，例如：

                 // 获取环境变量 如果不存在则使用默认值root

                         Env::get('database.username','root');

可以直接在配置文件中使用环境变量进行本地环境和服务器的自动配置，例如：

return [
    'hostname'  =>  Env::get('hostname','127.0.0.1'),
];


环境变量中设置的APP_DEBUG和APP_TRACE参数会自动生效（优先于应用的配置文件），其它参数则必须通过Env::get方法才能读取




Env::get()  相当与  $_ENV  ，即获取全部配置




============================================================================



.env的值dump不出来的原因：

   方法一：
       在TP5的新版中，已经取消了环境变量的优先识别，所以需要使用环境变量必须通过Env类来读取，改了php.ini文件variables_order = "EGPCS"之后，只是可以dump出环境变量，.env依然读取不到，该处不是bug，只是新旧版本的机制不同罢了

       不建议修改php.ini文件的variables_order，导致一些性能损失。

$_ENV为空，

       其原因通常是php的配置文件php.ini的配置项为：variables_order = "GPCS"。要想让$_ENV的值不为空，那么variables_order的值应该加上一个大写字母“E”，即：variables_order = "EGPCS"。


  方法二：

创建.env文件，设置参数后，读取不到数值问题？

修改thinkphp5核心文件，thinkphp/base.php
找到： 加载环境变量配置文件
if (is_array($val)) {
            foreach ($val as $k => $v) {
                $item = $name . '_' . strtoupper($k);
                putenv("$item=$v");

                // 自己修改 author:DXing1202
                $_ENV[$item] = $v;
                $_SERVER[$item] = $v;
            }
        } else {
            putenv("$name=$val");

            // 自己修改 author:DXing1202
            $_ENV[$name] = $val;
            $_SERVER[$name] = $val;
        }




=========================================================================


//我用下面这个方法解决问题了？

为什么.env打印不出来
为什么打印 $_ENV 和 $_SERVER 的结果一样，而且打印$_ENV也没显示.env文件的配置内容


          第一步：
                  $_ENV会为空，其原因通常是php的配置文件php.ini的配置项为：variables_order = "GPCS"。
                  要想让$_ENV的值不为空，那么variables_order的值应该加上一个大写字母“E”，即：variables_order = "EGPCS"。

          第二步：
                 Env不显示的问题，需要在base.php中 putenv的同时，将数据也写入$_ENV，就可以解决了

                 打开thinkphp目录下的base.php文件修改。54行左右 
 
                      putenv("$name=$val");

                 //写入环境变量，才能在打印$_ENV文件的时候显示出来配置的环境变量

                      $_ENV[$name]=$val;






















-------------------------------------------------------------------------------------------------------------------------------------------

3章 URL和路由

在本章主要对TP5框架的入口文件进行了详细的介绍 同时对如何隐藏入口文件以及入口文件的绑定进行了介绍

 3-1 入口文件 (07:23)


慕课网的版本 5.0:


     thinkPHP是一个单入口文件的框架，所有的请求都通过public/index.php进入，之后通过携带不同的参数转发到相应的控制器来实现功能
     
     单入口文件的定义: 应用程序所有的http请求都由一个文件接收并由该文件转发到功能代码中

     在入口文件中可以进行以下操作：

             1.必须引入thinkphp框架的引导文件（它可以帮助过滤些网站的安全、检测的问题）

             2.可以在这里定义在thinkphp/base.php中有的一些常量，如应用目录常量、配置文件目录常量等。没定义的话则会使用base.php中的默认值。


入口文件绑定

就是说,通过在入口文件(index.php)里设置

          define('BIND_MODULE','admin');//定义此常量,绑定admin模块,这时整个项目,只能访问admin这个模块

                  这样子绑定后，在地址栏输入 localhost/index/index 后，会直接访问  admin/index/index

          define('BIND_MODULE','admin/User');//绑定admin模块下的User控制器(只允许访问admin模块下的User控制器)

                  这样子绑定后，在地址栏输入 localhost/demo 后，会直接访问  admin/User/demo

          define('BIND_MODULE','admin/User/index');//绑定admin模块下的index控制器下的index方法(只允许访问admin模块下的index控制器下的index方法)

                  这样子绑定后，在地址栏输入 localhost 后，会直接访问  admin/User/index

                  可以使用户在访问网站时,只能访问指定模块下的控制器,或者只能访问指定模块下的指定控制器下的指定方法;


==========================================


这个功能存在的意义?

      当我们的项目在给第三方对接时,就可以重新定义一个入口文件(比如叫api.php),原本默认的入口文件是index.php依然存在,index.php这个入口文件是供正常用户访问项目的入口文件;

      此时输入localhost/api.php, 也可以访问到模块，和入口文件index.php的功能一样，但我们在 api.php中加入define('BIND_MODULE','api');就让入口文件api.php只能访问一个叫api的应用模块，不能访问其他模块。

      通过定义一个新的入口文件来限制第三方访问的模块(比如叫api.php);并且第三方只能通过api.php这个入口文件访问，才能得到他们想要的数据，同时我们一般把第三方想要的数据单独放在一个模块(比如api模块);

       这时可以在api.php里面设置,只允许第三方访问指定模块,或者指定方法;其他模块或者其他方法不允许其访问;


==========================================

新建入口文件绑定有两种方法：

        1、重新定义一个入口文件(比如叫api.php),原本默认的入口文件是index.php依然存在,index.php这个入口文件是供正常用户访问项目的入口文件;此时输入localhost/api.php, 也可以访问到模块，和入口文件index.php的功能一样，但我们在 api.php中加入define('BIND_MODULE','api');就让入口文件api.php只能访问一个叫api的应用模块，不能访问其他模块。





我用的版本5.1：



-------------------------------------------------------------------------------------------------------------------------------------------

 3-2 隐藏入口文件 (04:32)


慕课网的版本 5.0:


   1、这个隐藏入口文件有什么意义？


                隐藏入口文件是叫url看起来更好看  对seo优化有好处

   2、隐藏index.php不能访问admin问题

        看视频在第二章节中模块配置直接在public中新建admin模块的index控制器中的index方法，这个时候输入localhost/admin/index/index就可以访问，，为什么到了这一结输入就不行了，还得配置隐藏入口文件，感觉作者没有讲清楚，

        这一节的index.php/admin/index/index和配置教程的localhost/admin/index/index有什么不同，为什么到了这里去掉index.php就不行了呢？？这里的admin/index/index是哪个文件？


         答：没什么不同，你就当作在你访问的时候如：localhost/admin/index/index   会自动补上 index.php 入口文件而已   也就是说你最终访问的还是localhost/index.php/admin/index/index，因为在apache的重写规则中就写明了重写到index.php  这样就简化了路由。至于你为什么会这样 ，不清楚。我这里是没问题的


我用的版本5.1：

-------------------------------------------------------------------------------------------------------------------------------------------

 3-3 入口文件的绑定 (10:27)



慕课网的版本 5.0:

   1、但我们不特殊使用入口文件的绑定时，默认是绑定 index模块下的index控制器的index方法。

        即访问 http://localhost/think_web/public  相当与访问  http://localhost/think_web/public/index/index/index 

   2、如果我们在 public\index.php中 绑定了 admin\index

                         如：   // 绑定入口文件  绑定模块
                                define('BIND_MODULE', 'admin/index');

       那么我们访问 http://localhost/think_web/public  相当于访问 http://localhost/think_web/public/admin/index/index

         而如果想访问 原链接：http://localhost/think_web/public/admin/index/domo 的话，我们现在只能写成访问

                               http://localhost/think_web/public/domo

           访问 http://localhost/think_web/public/admin/index/domo，会报错。         


  3、如果我们在 public\index.php中 绑定了 admin\index ，即我们绑定了 admin模块下的index控制器，那么我们将无法访问 admin模块下的另一个控制器，类似admin\User.php

                         如：   // 绑定入口文件  绑定了 admin模块下的index控制器
 
                                       define('BIND_MODULE', 'admin/index');

                               那么访问 http://localhost/think_web/public/user/index，会报错。

                          但如果我们仅绑定了 admin 模块，如  define('BIND_MODULE', 'admin');
                          
                               那么访问 http://localhost/think_web/public/user/index 就不会报错了。 相当于访问了原链接：
                                     http://localhost/think_web/public/admin/user/index


  4、如果想为我们的网站提供一些接口，比如说想开放一些数据给第三方，所以这时候我们可能不想让第三方访问index.php这个文件，我们可以创建一个新的文件，比如说 api.php。

public\api.php 的内容：

                <?php
                     define( 'APP_PATH', __DIR__ . '/../app/' );
   
                     define( 'CONF_PATH', __DIR__ . '/../conf/');

                     require( __DIR__ . '/../thinkphp/start.php' );
                ?>


          绑定public\api.php有两种方法：

                  ①： 在 public\api.php 内容中添加  

                            define('BIND_MODULE', 'api'); // 绑定入口文件  绑定模块

                       然后再创建 app\api\controller\Index.php;

                       但我们访问 http://localhost/think_web/public/api.php 时，就会默认访问到应用目录app下的api模块的Index.php控制器中的index方法。   即访问到   app\api\Index\index

                         
                   注意： 用这种方法时，如果我们在app目录中没有api这个模块时，会直接报错


                  ②： 在应用配置 conf\config.php中添加：

                                // 入口自动绑定模块

                                   'auto_bind_module' => true           


                       如果我们开启了入口文件自动绑定的操作，
                           
                           那么当我们访问 http://localhost/think_web/public/api.php 时，系统会自动去找在应用目录app下的同名成的 api模块下Index.php控制器中的index方法。

                           当我们访问 http://localhost/think_web/public/index.php 时，系统会自动去找在应用目录app下的同名成的 index模块下Index.php控制器中的index方法。

                           而当我们想访问 应用目录app下的同名成的 api模块下Index.php控制器中的其他方法，比如domo方法，

                               我们只需要访问 http://localhost/think_web/public/api.php/index/demo

                                   而不需要 访问 http://localhost/think_web/public/api.php/api/index/demo, 多写一个api



我用的版本5.1：

-------------------------------------------------------------------------------------------------------------------------------------------

 3-4 路由 (08:47)

        其实这里的开启路由 就相当于给 链接 换一个别名，再去访问。


慕课网的版本 5.0:

   app\index\controller\Index.php 文件中：

	   public function info($id){

	        return "{$id}"	;   //这个需要有双引号能输出变量$id的值，如果用单引号，这只会输出字符串 ‘$id’  
	                            // http://localhost/think_web/public/index/index/info/id/5    访问info方法，并传参数为5
                                    // 如果我们想以   localhost/think_web/public/news/5.html 访问info方法，并传参数为5 , 则需要开启并设置路由 

	   }



     1、如果我们想开启路由，


        （1）我们需要在 thinkphp\convention.php 中设置

                            // 是否开启路由
                               'url_route_on'  => true,

         我们也可以把以上代码放到应用配置 conf\config.php 中，因为我们一般不会去修改 thinkphp\convention.php

            在 conf\config.php 中添加：
   
                                   // 是否开启路由

                                     'url_route_on'  =>  true,

                                   // 是否强制使用路由

                                     'url_route_must'         => false,


       （2）我们需要在 conf 目录中创建 route.php, 这个名字是固定的，不能修改成其他的

            route.php内容： 

                 <?php
                     return [
                              'news/:id' => 'index/index/info' //将news映射到index模块下的index控制器下的info方法,并传参id值给info方法 
                           ]
                 ?>

           注意： 当我们开启路由，并设置 'news/:id' => 'index/index/info' ，

                       再去访问   http://localhost/think_web/public/index/index/info/id/5，是会报错的：非法请求 

                  我们就只能通过 访问 http://localhost/think_web/public/news/5.html  
  

    2、使用路由的好处就是


        如果我们在 app\index\controller\Index.php 文件中：

	   public function info($id){

                echo url('index/index/index', ['id'=>10]) . "<br>";//输出结果为 /think_web/public/index/index/index/id/10.html

                echo url('index/index/info', ['id'=>10]) . "<br>"; //输出结果为: /think_web/public/news/10.html

	        return "{$id}";
	                                                    
	   }

    3、‘强制使用路由’的使用

            （1）、如果我们   在 conf\config.php 中添加：    'url_route_must'  => false,

                      我们还可以利用原来的访问链接 来访问其他方法，如： http://localhost/think_web/public/index/index/demo  

            （2）、但当我们 在 conf\config.php 中添加: 'url_route_must'  => true, 时

                     我们再去访问  http://localhost/think_web/public/index/index/demo 则会报错

                  我们必须为 demo方法设置路由，如                                
                
                  在route.php内容中： 

                 <?php
                     return [
                              'news/:id' => 'index/index/info'， //将news映射到index模块下的index控制器下的info方法,并传参id值给info方法 

                              'index/index/dome' => 'index/index/dome' //这个将路由配置跟原来的url一样（也可以设置成不一样）
                           ]
                 ?>

                    这样我们就可以访问 http://localhost/think_web/public/index/index/demo

                    当然我们在一般情况下还是不会随便开启强制使用路由，一般设置 'url_route_must'  => false, 这样我们才不用去访问每个方法时，都需要配置新的路由给方法，再去访问。



我用的版本5.1：

       TP5.1 不能自定义info()方法 得换个函方法名
  


-------------------------------------------------------------------------------------------------------------------------------------------


第4章 请求和响应
在本章主要对TP5的请求以及请求的参数获取等做了详细的介绍，另外对在特定环境下返回不同的数据格式 学习了助手函数input的使用方法
最近学习


 4-1 请求对象获取 (03:34)
        
          请求对象 Request 

        有三种方式能让我们获取到request对象

      (1)
	  namespace app\index\controller;
	  
	  class Index{

	     public function index(){
	        
	           $request = request();  //第一种办法	        

	           dump($request);

	     }
	  }


      (2)
	  namespace app\index\controller;
	  use think\Request;
	  class Index{

	     public function index(){
	        	             
	           $request = Request::instance();  //第二种办法

	           dump($request);
	     }
	  }


     (3)
	  namespace app\index\controller;
          use think\Request;
	  class Index{

	     public function index(Request $request){

	           dump($request);
	     }
	  }



      (4)获取请求对象的第四种方法

                     <?php
                             namespace app\index\controller;
                             class Index extends \think\Controller
                             {
                                 public function demo()
                                 {
                                   dump($this->request->param());
                                 }
                             }

          可以让当前控制器继承自基类Controller，基类中有一个属性$request，这里面保存的是请求对象Request实例。这种方式更方便，类似于请求类对象的快捷方式。





-------------------------------------------------------------------------------------------------------------------------------------------


 4-2 请求对象参数获取 (17:38)


	  namespace app\index\controller;
	  use think\Request;
	  class Index{

	     public function index(Request $request){  //第三种方法，直接在方法中注入
	        
	     # 获取浏览器输入框的值
                #比如访问 http://localhost/think_web/public/index/index/index/type/5.html?id=10
    
	           dump( $request->domain());    //  输入结果：  string(16) "http://localhost"
	           dump( $request->pathinfo()); //返回的路径包含 ‘.html’后缀，可以让别人不知道我们是用什么语音开发的  输出结果：  string(24) "index/index/index/5.html"
               dump( $request->path());     //返回的路径且不包含 ‘.html’后缀    输入结果： string(19) "index/index/index/5"

            # 请求类型
               dump( $request->method());  //获取请求类型    输入结果：  string(3) "GET"
               dump( $request->isGet());   //判断当前请求是否为 ‘get’ 请求    输出结果：  bool(true)
               dump( $request->isPost());   //判断当前请求是否为 ‘post’ 请求    输出结果：  bool(false)
               dump( $request->isAjax());   //判断当前请求是否为 ‘ajax’ 请求    输出结果：  bool(false)


            # 请求的参数

               dump( $request->get()); 
               //获取所有get请求参数名以及参数值，但是不会获取 pathinfo 中的参数和参数值，比如获取不到 type=5。  输出结果： array(1) {  ["id"] => string(2) "10"  }

               dump( $request->param());
               //这个是可以获取所有的请求参数以及请求参数的值。  输出结果：array(2) { ["id"] => string(2) "10" ["type"] => string(1) "5" }
              
               dump( $request->post());
               //获取所有post请求参数名以及参数值。

               
               //设置session
               session('name','arvin');
               dump( $request->session());   //获取会话session中的值
 
               #######################################################################################

                 注意： 如果我们要保存session值，需要在应用配置conf\config.php中

                        //重新配置session, 来覆盖掉惯例配置convention.php的session配置

                          'session'  => [

                                  'id'             => '',

                                  // SESSION_ID的提交变量,解决flash上传跨域
                                  'var_session_id' => '',

                                  // SESSION 前缀
                                  'prefix'         => 'think',

                                  // 驱动方式 支持redis memcache memcached
                                  'type'           => '',

                                  // 是否自动开启 SESSION
                                    'auto_start'     => true,
                                  //'httponly'       => true,   //删除这两行代码就可以保存session的值
                                  //'secure'         => true,   //删除这两行代码就可以保存session的值
                              ],
                ######################################################################################
                 

                //直接获取某个请求参数的值
                dump( $request->param('type'));  //这里直接获取请求参数type的值。
                dump( $request->cookie('type')); // get,post,param,sessioin,cookie 都可以利用这种方式直接获取某个参数的值


              # 获取模块 控制器 操作
                dump( $request->module());      //获取当前的模块名称                    输出结果： string(5) "index"
                dump( $request->controller());  //获取当前的控制器名称                  输出结果： string(5) "Index"
                dump( $request->action());      //获取当前操作action的名称，即方法名    输出结果： string(5) "index"

              #返回当前url
               dump( $request->url());   //输出结果:string(53) "/think_web/public/index/index/index/type/5.html?id=10"
               dump( $request->baseurl());  //输出结果: string(47) "/think_web/public/index/index/index/type/5.html"
	     }
	  }


           注意：  如果还想知道 $request 还有哪些 方法，我们可以在 thinkphp\library\think\Request.php


-------------------------------------------------------------------------------------------------------------------------------------------


 4-3 input助手函数 (17:59)

      input函数 位于 thinkphp\helper.php 中。

 
      input函数 就是相当于 $request 对象的作用


      我们可以通过 Request 对象完成全局输入变量的检测、获取和安全过滤，支持包括 $_GET 、$_POST 、 $_REQUEST 、 $_SERVER 、 $_SESSION 、 $_COOKIE 、 $_ENV 等系统变量，以及文件上传信息。

      同样可以通过 input函数 获取以上所有的系统变量。


      1、检测变量是否设置

                    可以使用 has 方法来检测一个变量参数是否设置，如下：

                                    Request::instance()->has('id','get');
                                    Request::instance()->has('name','post');

                    或者使用助手函数：
                    
                                    input('?get.id');
                                    input('?post.name');  


          注意：变量检测可以支持所有支持的系统变量



      2、变量获取

              （1）、变量获取使用 \think\Request 类的如下方法及参数：

                         变量类型方法('变量名/变量修饰符','默认值','过滤方法')
                         

              （2）、变量类型方法包括：

                            方法                描述

                            param               获取当前请求的变量

                            get                 获取 $_GET 变量

                            post                获取 $_POST 变量

                            put                 获取 PUT 变量

                            delete              获取 DELETE 变量

                            session             获取 $_SESSION 变量

                            cookie              获取 $_COOKIE 变量

                            request             获取 $_REQUEST 变量

                            server              获取 $_SERVER 变量

                            env                 获取 $_ENV 变量

                            route               获取 路由（包括PATHINFO） 变量

                            file                获取 $_FILES 变量



      3、获取 PARAM 变量以及其他系统变量

           PARAM变量是框架提供的用于自动识别 GET 、 POST 或者 PUT 请求的一种变量获取方式，是系统推荐的获取请求参数的方法，用法如下：

                      // 获取当前请求的name变量

                                  Request::instance()->param('name')

                      // 获取当前请求的所有变量（经过过滤）

                                  Request::instance()->param();

                      // 获取当前请求的所有变量（原始数据）

                                  Request::instance()->param(false);

                      // 获取当前请求的所有变量（包含上传文件）

                                  Request::instance()->param(true


                  注意： param方法会把当前请求类型的参数和PATH_INFO变量以及GET请求合



                      使用助手函数实现：

                                    input('param.name');

                                    input('param.');

                                    或者

                                    input('name');

                                    input('');

                      因为 input 函数默认就采用PARAM变量读取方式。


                获取其他系统变量如：$_GET 、$_POST 、 $_REQUEST 、 $_SERVER 、 $_SESSION 、 $_COOKIE 、 $_ENV， 和以上获取param变量的方法相同。 

                注意：input（）可能会引起函数重新定义，推荐使用Request对象获取


        4、获取部分

                如果你只需要获取当前请求的部分参数，可以使用：

                        // 只获取当前请求的id和name变量

                        Request::instance()->only('id,name');

                或者使用数组方式

                        // 只获取当前请求的id和name变量

                        Request::instance()->only(['id','name']

                默认获取的是当前请求参数，如果需要获取其它类型的参数，可以使用第二个参数，例如：

                            // 只获取GET请求的id和name变量

                                        Request::instance()->only(['id','name'],'get');

                            // 只获取POST请求的id和name变量

                                        Request::instance()->only(['id','name'],'post');



        5、排除部分变量

              也支持排除某些变量获取，例如

                       // 排除id和name变量

                               Request::instance()->except('id,name');

                      或者使用数组方式

                       // 排除id和name变量

                               Request::instance()->except(['id','name']);

              同样支持指定变量类型获取：

                       // 排除GET请求的id和name变量

                               Request::instance()->except(['id','name'],'get');
 
                       // 排除POST请求的id和name变量

                               Request::instance()->except(['id','name'],'post');



       6、变量修饰符

              input 函数支持对变量使用修饰符功能，可以更好的过滤变量。

              用法如下：

                       input('变量类型.变量名/修饰符');

                       或者

                       Request::instance()->变量类型('变量名/修饰符');


              例如：

                     input('get.id/d');

                     input('post.name/s');

                     input('post.ids/a');

                     Request::instance()->get('id/d');

            ThinkPHP5.0版本默认的变量修饰符是 /s ，如果需要传入字符串之外的变量可以使用下面的修饰符，包括：

                     修饰符             作用

                       s                强制转换为字符串类型

                       d                强制转换为整型类型

                       b                强制转换为布尔类型

                       a                强制转换为数组类型
                       
                       f                强制转换为浮点类型





 #######################################################################

      其他笔记：

              tp5用$rquest->param（）获取传递过来的参数，如果参数有重复的情况会覆盖，

                            覆盖的规则如下：pathinfo参数会覆盖post中的参数，post中的参数会覆盖get中的参数。


                1、input助手函数也是获取对象里面的参数. input('传递方式','参数','对参数过滤')

                       注意获取请求的参数值，尽可能带上请求的方式，如：input(get.id) ，如果获取的值不存在时，可通过第二个值进行默认值设置，第三个值用来过滤获取的值，例如可将值转换成intval。


                2、同时也可以通过request对象下的相关方法获取对应的参数或值，来对值进行相关操作

                    <?php
                    namespace app\index\controller;
                    use think\Request;
                    class Index{

                            public function index(Request $request){

                            //dump($request->param());//param方法会返回post,get,pathinfo传递的所有值,即合并
                            //http://localhost/imooc/public/index/index/index/type/5.html?id=10 
                            //$res = input('get.id');//10
                            //dump($request->get('id'));//10
                            //$res = input('post.id','100');//没有则默认100，结果100
                            //dump($request->post('id','100'));//100
                            //$res = input('post.id','abc','intval');//没有则默认100，结果100
                            //dump($request->post('id','100'));//100

                           #获取类型
                                    //'get', 'post',
                                    //'put', 'patch',
                                    //'delete', 'param',
                                    //'request', 'session',
                                    //'cookie', 'server',
                                    //'env', 'path', 'file'
                   
                           //通过input助手函数对request中参数进行获取，#建议使用request对象（Request $request）#，避免重复定义相同函数

                                    //$res = input('patch.id');
                                    //session('emial','987@qq.com');
                                    //dump(input('session.emial'));
                                    //dump(input('session.emials','imooc@qq.com'));

                           //不存在默认imooc

                                    session('ss','   123   ');
                                    $res = $request->session('ss','','trim');//trim过滤前后空格
                                    dump($res);
                        }
                    }






-------------------------------------------------------------------------------------------------------------------------------------------


 4-4 响应对象 (11:15)

         响应对象 response

     在 惯例配置thinkphp\convention.php中， 响应对象response 默认返回的数据为 ‘html’格式   
     
        // 默认输出类型
                        'default_return_type'    => 'html',


      如果我们想return 其他格式的数据，如json格式，我们可以方法中动态设置，如：


		namespace app\index\controller;
		use think\Request;
                use think\Config;
		class Index{

		      public  function index(Request $request){

                  $res = [

                       'code'    => 200,
                       'result'  => [
                                'list' => [1,2,3,4,5,6]
                       ]

                  ];

                  //echo "123";  回应请求时，虽然可以用echo，但一般不建议用echo或者die
                  //die();      
                  //return "123"; 用return 比 echo  好 , return 就是 response 响应
                  //dump($res);

                  Config::set('default_return_type' , 'json');  //动态设置 返回 json 格式数据
                  return $res;
                     
		      }

		}             

                输出结果为json格式的数据： {"code":200,"result":{"list":[1,2,3,4,5,6]}}


                如果设置为xml格式：
                                   Config::set('default_return_type' , 'json');  //动态设置 返回 json 格式数据
                                   return $res;


                输出结果为xml格式的数据： 

                                        <think>
                                            <code>200</code>
                                            <result>
                                                <list>
                                                    <item id="0">1</item>
                                                    <item id="1">2</item>
                                                    <item id="2">3</item>
                                                    <item id="3">4</item>
                                                    <item id="4">5</item>
                                                    <item id="5">6</item>
                                                </list>
                                            </result>
                                        </think>


     设置app\api\controller\Index.php中getUserInfo方法返回数据格式的方式：

      （1）、我们可以在应用配置conf目录下新建api\config.php, 配置  'default_return_type' => 'json' ，使其返回json格式的数据，就不会报错了  
	<?php 
	 //responses的用处就是： 我们可以app目录下，新建api\controller\Index.php 作为接口，来返回数据，如以下我们新建一个getUserInfo函数
	 namespace app\api\controller;
	 
	 class  Index{

	   public function getUserInfo(){

	       $data = [

	         'code' => 200,
	         'result' => [

	             'username' => 'arvin',
	             'useremail' => '109565463@qq.om'
	         ]
	       ];

	       return $data;  //如果在这里直接返回数组类型的数据是会报错。  
	                      //我们可以在应用配置conf目录下新建api\config.php, 配置  'default_return_type' => 'json' ，使其返回json格式的数据，就不会报错了
            }

	   }
	?>



     （2）在（1）方法中，有一个缺点： 就是如果我们是在应用配置conf目录下新建api\config.php, 配置  'default_return_type' => 'json' ，使其返回json格式的数据，那么会导致 app\api\controller\Index.php 中所有的返回数据 都修改成了 json格式， 很有可能导致有些地方报错。

          所以一般我们可以采取以下的动态设置的方式：
    
		<?php
			  
			 //responses的用处就是： 我们可以app目录下，新建api\controller\Index.php 作为接口，来返回数据，如以下我们新建一个getUserInfo函数
			 namespace app\api\controller;
		     use think\Config;
			 class  Index{

			   public function index(){

			       return 'this is api Index index';

			   }

			   public function getUserInfo($type = 'json'){   // $type 如果为空，则默认设置为json格式

			   	  if(!in_array($type, ['json','jsonp','xml'])){

			   	  	  $type = 'json';
			   	  }
		    
		        Config::set('default_return_type', $type);
			       $data = [

			         'code' => 200,
			         'result' => [
			             'username' => 'arvin',
			             'useremail' => '109565463@qq.om'
			         ]
			       ];


			       return $data;  //如果在这里直接返回数组类型的数据是会报错。  
			                      //我们可以在应用配置conf目录下新建api\config.php, 配置  'default_return_type' => 'json' ，使其返回json格式的数据，就不会报错了
			  }

			 }

		?>      

             第二种方式的好处就是： 如果我们想返回不同格式的数据，那么我们只要设置不同的$type值就好了，而且我们可以在路径url中不同的$type参数值。如下：

               ①想返回 json 格式的数据： http://localhost/think_web/public/api/index/getUserInfo?type=json

               ②想返回 xml 格式的数据： http://localhost/think_web/public/api/index/getUserInfo?type=xml 
    
              这样动态设置，就不用再修改我们的应用配置文件conf\api\config.php了。

              注意： 在url中，我们可以加后缀 '.html' 和原来的url访问是一样的。如：

                    http://localhost/think_web/public/api/index/getUserInfo.html?type=json

               这样的好处是可以让别人不知道你用了什么语言编写。
       

       注意：return response(json_encode($data),200)->send(); 

             全局返回结果别忘记 ->send() 不然会返回不了数据



-------------------------------------------------------------------------------------------------------------------------------------------

第5章 视图和模板

通过本章的学习，能了解TP5模板的使用方法，循环嵌套比较标签 变量常量的输出等等

 5-1 视图view (23:39)

       学习这一章的时候可以把之前app目录下的代码全部先删除，我这里就不删除了，把之前的代码全部注释掉。

     1、如果在 app\index\controller\Index.php中内容如下：

	     namespace app\index\controller;
	     class Index{
                public function index(){

                     #默认模板的地址
                     #app/index/view/index/index.html

              	     return view();
                }
	     }       
 
          访问：http://localhost/think_web/public/index/index/index
          会报错：模板文件不存在:D:\xampp\htdocs\think_web\public/../app/index\view\index\index.html

          解释：当我们 去 return view（）；系统会自动去 app\index 模块下去找 view目录（和controller目录同级） 下 index目录中的index.html。        
          当我们新创建 app\index\view\index\index.html,内容如下：
      
				<!DOCTYPE html>
				<html lang="en">
				<head>
					<meta charset="utf-8">
					<title>Document</title>
				</head>
				<body>
				   <h1>这里是 index.html</h1>
				</body>
				</html>       

           然后我们再去  访问：http://localhost/think_web/public/index/index/index ，就不会报错。

           在页面显示结果为：     这里是 index.html      


   ===================================================================


     2、如果把 app\index\controller\Index.php中的内容修改成如下：

	     namespace app\index\controller;
	     class Index{
                public function index(){

                     #默认模板的地址
                     #app/index/view/index/index.html

                     # 传递第一个参数， 修改模板文件目录的
                     # （upload）: app/index/view/index/upload.html

              	     return view('upload');
                }
	     }    

            访问：http://localhost/think_web/public/index/index/index

            会报错： 模板文件不存在:D:\xampp\htdocs\think_web\public/../app/index\view\index\upload.html
     
            解释：当我们给 view函数添加参数时，如 return view（'upload'）；系统会自动去 app\index 模块下去找 view目录（和controller目录同级） 下 index目录中的upload.html。

            当我们新创建 app\index\view\index\upload.html,内容如下：
      
				<!DOCTYPE html>
				<html lang="en">
				<head>
					<meta charset="utf-8">
					<title>Document</title>
				</head>
				<body>
				   <h1>这里是 upload.html</h1>
				</body>
				</html>   

           然后我们再去  访问：http://localhost/think_web/public/index/index/index ，就不会报错。

           在页面显示结果为：     这里是 upload.html     


   ==========================================================================


     3、如果把 app\index\controller\Index.php中的‘return view();’内容修改成如下：

                   #（public/upload）: app/index/view/public/upload.html
                   return view('public/upload');

            访问：http://localhost/think_web/public/index/index/index

            会报错： 模板文件不存在:D:\xampp\htdocs\think_web\public/../app/index\view\public\upload.html

            解释：当我们给 view函数添加参数时，如 return view（'public/upload）；系统会自动去 app\index 模块下去找 view目录（和controller目录同级） 下 public目录(和index目录同级)中的upload.html。

            当我们新创建 app\index\view\public\upload.html,内容如下：
      
				<!DOCTYPE html>
				<html lang="en">
				<head>
					<meta charset="utf-8">
					<title>Document</title>
				</head>
				<body>
				     <h1>这里是 public\upload.html</h1>
				</body>
				</html>  

           然后我们再去  访问：http://localhost/think_web/public/index/index/index ，就不会报错。

           在页面显示结果为：    这里是 public\upload.html


  ============================================================================


     4、

      （1）  如果把 app\index\controller\Index.php中的‘return view();’内容修改成如下：
                  
                   return view('./index.html');

            访问：http://localhost/think_web/public/index/index/index

            会报错： 模板文件不存在:./index.html

            解析： 我们都知道thinkphp是单入口文件。它默认的入口在public目录下，我们可以在public目录下新建一个 index.html

            think_web\public\index.html 内容：

				<!DOCTYPE html>
				<html lang="en">
				<head>
					<meta charset="utf-8">
					<title>Document</title>
				</head>
				<body>
				   <h1>这里是 think_web\public\index.html( 和 应用入口文件 index.php 同级)</h1>
				</body>
				</html>

            
           然后我们再去  访问：http://localhost/think_web/public/index/index/index ，就不会报错。

           在页面显示结果为：    这里是 think_web\public\index.html( 和 应用入口文件 index.php 同级)

           综上我们可知， return view('./index.html');  访问的是  think_web\public\index.html( 和 应用入口文件 index.php 同级)

     
       （2） 如果把 app\index\controller\Index.php中的‘return view();’内容修改成如下：
                  
                   return view('./html/index.html');

            think_web\public\html\index.html 内容：

				<!DOCTYPE html>
				<html lang="en">
				<head>
					<meta charset="utf-8">
					<title>Document</title>
				</head>
				<body>
				  <h1>这里是 think_web\public\html\index.html( html目录 和 应用入口文件 index.php 同级)</h1>
				</body>
				</html>
  
           然后我们再去  访问：http://localhost/think_web/public/index/index/index ，

           在页面显示结果为：  这里是 think_web\public\html\index.html( html目录 和 应用入口文件 index.php 同级)

           综上我们可知， return view('./html/index.html');  访问的是 think_web\public\html\index.html( html目录 和 应用入口文件 index.php 同级)

           由（1）和（2）可知，如果以 ./ 开头，那么就会找到我们应用入口文件index.php同级开始的模板文件

           
           注意： 
                 ①、如果我们直接写 view('index.html')，而没有 ‘./’开头，是会报错的。
                  
                 ②、 写view('index')，访问：http://localhost/think_web/public/index/index/index 才不会报错。会访问到app/index\view\index\index.html。



  =======================================================================


     5、当 view 函数 接受 第二个参数：

        如果把 app\index\controller\Index.php中的‘return view();’内容修改成如下：
                  
             return view('index', [

                   'email' => '1095654362@qq.com',
                   'username' => 'arvin'
              	 ]);

        访问：http://localhost/think_web/public/index/index/index

        同时修改 view/index 目录下 index.html 内容为如下：

				<!DOCTYPE html>
				<html lang="en">
				<head>
					<meta charset="utf-8">
					<title>Document</title>
				</head>
				<body>
				   <h1>这里是 index.html  这是在 view/index 目录下</h1>
				   <p>{$email}</p>
				   <p>{$username}</p>
				</body>
				</html>

           在页面显示结果为：

                             这里是 index.html 这是在 view/index 目录下
                             1095654362@qq.com
                             arvin

          由上可以，当我们设置：

             return view('index', [

                   'email' => '1095654362@qq.com',
                   'username' => 'arvin'
              	 ]);

          ‘email’和 ‘username’ 是我们向 view/index/index.html 文件 中传递的变量。

           而且我们在 .html 文件中 取变量值的时候，需要用到花括号'{ }',  如 ‘{$email}’ 或者 ‘{$username}’


   ====================================================================


      6、当 view 函数 接受 第三个参数是：

        如果把 app\index\controller\Index.php中的‘return view();’内容修改成如下：
                  
             	 return view('index', [

                   'email' => '1095654362@qq.com',
                   'username' => 'arvin'
              	 ] ,[

                     'STATIC' => '当前是static的替换内容'    //这里是添加的第三个参数
              	 ]);
      

        访问：http://localhost/think_web/public/index/index/index

        同时修改 view/index 目录下 index.html 内容为如下：

				<!DOCTYPE html>
				<html lang="en">
				<head>
					<meta charset="utf-8">
					<title>Document</title>
				</head>
				<body>
				   <h1>这里是 index.html  这是在 view/index 目录下</h1>
				   <p>{$email}</p>
				   <p>{$username}</p>

                                   <p>STATIC</p>
				</body>
				</html>

           在页面显示结果为：

                             这里是 index.html 这是在 view/index 目录下
                             1095654362@qq.com
                             arvin

                             当前是static的替换内容


          解析： 由上可知，当我们把 view()函数中设置第三个参数时，如第三个参数设置成：[ 'STATIC' => '当前是static的替换内容' ] 后，

                 意思则是在 view/index 目录下 index.html中： 所有的‘STATIC’字符串  都会在页面替换显示成“当前是static的替换内容”字符串。 



     #######################################################################################

      以上 1-6 点 我们都是用 view（）来返回页面，但是用view（）来返回页面时有缺陷，可能会出现bug，所以一般在开发web项目时，不建议使用view（）。

      7、第二种方法显示页面：继承Controller类， 使用Controller类中的 fetch方法

      （1）如果把 app\index\controller\Index.php中内容修改成如下：

    namespace app\index\controller;
    use think\Controller;
    class Index extends Controller{    //继承Controller,我们可以使用Controller中很多方法。

              public function index(){

                return $this->fetch();   //使用 fetch（）返回视图
              }
    }

        访问：http://localhost/think_web/public/index/index/index

        同时修改 view/index 目录下 index.html 内容为如下：

				<!DOCTYPE html>
				<html lang="en">
				<head>
					<meta charset="utf-8">
					<title>Document</title>
				</head>
				<body>
				   <h1>这里是 index.html  这是在 view/index 目录下</h1>

                                   <p>STATIC</p>
				</body>
				</html>

           在页面显示结果为：

                             这里是 index.html 这是在 view/index 目录下

                             当前是static的替换内容。


       （2） fetch（）同样可以传参数

                如果把（1）中的 ‘ return $this->fetch();  ’  改成 ‘ return $this->fetch(‘upload’);  ’


            访问：http://localhost/think_web/public/index/index/index
     
            解释：当我们给fetch()函数添加参数时，如 $this->fetch(‘upload’) ；系统会自动去 app\index 模块下去找 view目录（和controller目录同级） 下 index目录中的upload.html。( 与view（）是同个原理 )

            当我们新创建 app\index\view\index\upload.html,内容如下：
      
				<!DOCTYPE html>
				<html lang="en">
				<head>
					<meta charset="utf-8">
					<title>Document</title>
				</head>
				<body>
				   <h1>这里是 upload.html</h1>
				</body>
				</html>   

           然后我们再去  访问：http://localhost/think_web/public/index/index/index ，就不会报错。

           在页面显示结果为：     这里是 upload.html   



     （3） 如果把（1）中的 ‘ return $this->fetch();  ’  改成 ‘ return $this->fetch('public/upload');  ’
 
            访问：http://localhost/think_web/public/index/index/index

            解释：当我们给fetch()函数添加参数时，如 fetch('public/upload') ；系统会自动去 app\index 模块下去找 view目录（和controller目录同级） 下 public目录(和index目录同级)中的upload.html。

            当我们新创建 app\index\view\public\upload.html,内容如下：
      
				<!DOCTYPE html>
				<html lang="en">
				<head>
					<meta charset="utf-8">
					<title>Document</title>
				</head>
				<body>
				     <h1>这里是 public\upload.html</h1>
				</body>
				</html>  

           然后我们再去  访问：http://localhost/think_web/public/index/index/index ，就不会报错。

           在页面显示结果为：    这里是 public\upload.html


     （4） 如果以 ./ 开头，那么就会找到我们应用入口文件index.php同级开始的模板文件 , 与view（）函数情况相同

               return $this->fetch('./123.html')  或者  return $this->fetch('./html/123.html')  与 view（'./123.html'） 或者 view('./html/123.html') 情况相同，参考view（）函数

       
     （5） 给fetch（）函数设置第二个参数，

             如： 
                return $this->fetch('index', [

                   'email' => '1095654362@qq.com',
                   'username' => 'arvin'
                ]);

            情况与 view（）相同，参考view（）。

       
     （6） 给fetch（）函数设置第三个参数，

             如： 
                return $this->fetch('index', [

                   'email' => '1095654362@qq.com',
                   'username' => 'arvin'
                ] ,[

                     'STATIC' => '当前是static的替换内容'
                ]);

            情况与 view（）相同，参考view（）。

   

    8、继承extends controller 的好处：

        （1）我们传参数不一定要用 fetch() 或者 view(), 我们可以使用 controller类中的 assign() 函数来传参

             如下：
     如果把 app\index\controller\Index.php中内容修改成如下：

    namespace app\index\controller;
    use think\Controller;
    class Index extends Controller{    //继承Controller,我们可以使用Controller中很多方法。

              public function index(){

                $this->assign('assign', '这是assign 传递的值');   // 使用 controller类中的 assign() 函数来传参

                return $this->fetch('index', [

                   'email' => '1095654362@qq.com',
                   'username' => 'arvin'
                ] ,[

                     'STATIC' => '当前是static的替换内容'
                ]);

              }
    }

        访问：http://localhost/think_web/public/index/index/index

        同时修改 view/index 目录下 index.html 内容为如下：

				<!DOCTYPE html>
				<html lang="en">
				<head>
					<meta charset="utf-8">
					<title>Document</title>
				</head>
				<body>
 				   <h1>这里是 index.html  这是在 view/index 目录下</h1>
                                   <p>{$email}</p>
                                   <p>{$username}</p>
                                   <p>{$assign}</p>
                                   <p>STATIC</p>
				</body>
				</html>

           在页面显示结果为：

                             这里是 index.html 这是在 view/index 目录下  
                             1095654362@qq.com
                             arvin
                             这是assign 传递的值
                             当前是static的替换内容

                
      9、返回视图除了 $this->fetch（），还有 $this->display() 

            例子：

                 #如果想传递字符串
                 //return $this->display('这是一个字符串');

                 #如果想传递字符串同时传递参数
                // $this->assign('user', 'arvin');
                //  return $this->display('这是{$email}一个字符串', 

                //     'email' => '1095654362@qq.com'
                // );


      10、  $this->fetch（） 和 $this->display() 的区别

              使用 $this->fetch（）时，我们需要有模板文件，即我们要访问的 .html文件 是存在的，是我们有创建的，这样才不会报错

              但如果使用  $this->display()，就不需要有模板文件， 即不需要 .html文件， 但使用 display（）时需要向页面传递字符串或者参数，可以如下：

                 #如果想传递字符串
                 //return $this->display('这是一个字符串');

                 #如果想传递字符串同时传递参数
                // $this->assign('user', 'arvin');
                //  return $this->display('这是{$email}一个字符串', 

                //     'email' => '1095654362@qq.com'
                // );

             在开发过程中，一般建议使用 $this->fetch(), 才能实现 MVC模式。 $this->display() 没有将 视图层和控制层 分开。

其他笔记：
             fetch直接使用模板文件

             display直接将字符串进行模板替换和变量输出

             在接口中需要提供界面，没有使用模板文件，可以直接使用display，传递的第一个参数是字符串

             开发有前台的建议用fetch，可以使MVC分离：创建view层级，新建模板文件，直接将fetch的第一个参数指向这个模板文件




-------------------------------------------------------------------------------------------------------------------------------------------

 5-2 变量输出、赋值和替换 (20:43)

      在这之后的学习，我们都使用 use think\Controller,  class Index extends Controller{ } 的 方式

     1、变量输出的第一种方式：（使用花括号进行变量输出，类似：{$email} ） 和利用fetch（）的第二个参数进行赋值
   
           在 app\index\controller\Index.php中 使用 fetch（）函数的第二个参数进行传变量给 .html 文件，如下 ：

                      namespace app\index\controller;
                      use think\Controller;
                      class Index extends Controller{

                           public function index(){

                                return $this->fetch('index',
                                  [ 'email' => '1095654632@qq.com']
                              );
                           }
                      }

           访问：http://localhost/think_web/public/index/index/index

            在view/index 目录下 index.html 文件中 使用花括号进行变量输出,如下：

				<!DOCTYPE html>
				<html lang="en">
				<head>
					<meta charset="utf-8">
					<title>Document</title>
				</head>
				<body>
				   <h1>这里是 index.html  这是在 view/index 目录下</h1>
				   <p>{$email}</p>
				</body>
				</html>


            解析： 我们的模板是 .html文件，但是当前的系统是 php， 所有模板.html文件最终也会编译成 php 文件，再输出我们想要的结果。
                  
                   那么我们编译的文件 在 runtime\temp 目录中。如果在temp目录中有很多文件，我们可以将temp目录删除掉，之后再回到浏览器运行一次，访问链接。 temp目录就会重新被创建，并且目录下有一个文件。


                   在.html文件中，为什么我们能使用 花括号{ } 进行变量输出？

                      原因是我们在惯例配置 thinkphp/convention.php 中 有进行了模板配置， 我们也可以将 惯例配置中对 模板配置 的全部代码复制在应用配置中， 然后 在 应用配置中 修改模板配置， 使其使用其他符号，也可以进行变量输出。

     ================模板配置的代码=========================

            //模板配置
            'template'               => [
                    // 模板引擎类型 支持 php think 支持扩展
                    'type'         => 'Think',
                    // 视图基础目录，配置目录为所有模块的视图起始目录
                    'view_base'    => '',
                    // 当前模板的视图目录 留空为自动获取
                    'view_path'    => '',
                    // 模板后缀
                    'view_suffix'  => 'html',
                    // 模板文件名分隔符
                    'view_depr'    => DS,
                    // 模板引擎普通标签开始标记
                    'tpl_begin'    => '{',
                    // 模板引擎普通标签结束标记
                    'tpl_end'      => '}',
                    // 标签库标签开始标记
                    'taglib_begin' => '{',
                    // 标签库标签结束标记
                    'taglib_end'   => '}',
                ]

    ================模板配置的代码=========================

         模板配置中： 'tpl_begin' 和  'tpl_end' 就是设置变量输出的所用的特定符号。

               若我们 将   'tpl_begin'    => '{',  修改为   'tpl_begin'    => '{imooc',

            那么我们在 .html文件中的 ‘{$email}’  ,在页面的显示将是 ‘{$email}’ ,而不是变量值 ‘1095654362@qq.com’
                       
                  只有在 .html文件中的 ‘{imooc$email}’  ,才会在页面的显示变量值 ‘1095654362@qq.com’。
 
        'tpl_end'的修改 和  'tpl_begin' 是一样的道理。

         一般我们都是使用  'tpl_begin' 和  'tpl_end'  的默认值：花括号{}，只用当前端的符号和  'tpl_begin'以及'tpl_end'的特定符号发生冲突时，我们才会去修改这两者的值。 




     2、变量输出的第二种方式： 直接使用 $this->assign('key', 'value');  可以直接分配变量到页面中。

           在 app\index\controller\Index.php中 使用 fetch（）函数的第二个参数 和 assign（）进行传变量给 .html 文件，如下 ：

                      namespace app\index\controller;
                      use think\Controller;
                      class Index extends Controller{


                           public function index(){

                                $this->assign('key', 'value');
                                return $this->fetch('index',
                                  [ 'email' => '1095654632@qq.com',
                                     'user' => 'arvin'
                              ]
                              );
                           }
                      }          


     3、变量输出的第三种方式：

           如果类继承了 think\Controller, 可以使用  $this->view->key2 = 'value2' 进行传参。

           在 app\index\controller\Index.php中 使用 第三种方式 进行传变量给 .html 文件，如下 ：

                      namespace app\index\controller;
                      use think\Controller;
                      class Index extends Controller{

                           public function index(){

                                $this->assign('key', 'value');   // 第二种方式
                               
                                $this->view->key2 = 'value2';    // 第三种方式

                                return $this->fetch('index',
                                  [ 'email' => '1095654632@qq.com',  // 第一种方式   
                                     'user' => 'arvin'
                              ]
                              );
                           }
                      }  

     4、变量输出的第四种方式： 

           引入View对象： use think\View

           然后使用View对象的share（）函数： View::share('key3', 'value3');

           在 app\index\controller\Index.php中 使用 第四种方式 进行传变量给 .html 文件，如下 ：

                      namespace app\index\controller;
                      use think\Controller;
                      use think\View;
                      class Index extends Controller{

                           public function index(){

                                $this->assign('key', 'value');   // 第二种方式
                               
                                $this->view->key2 = 'value2';    // 第三种方式

                                View::share( 'key3', 'value3' ) ;  // 第四种方式                             

                                return $this->fetch('index',
                                  [ 'email' => '1095654632@qq.com',  // 第一种方式   
                                     'user' => 'arvin'
                              ]
                              );
                           }
                      }      



       以上是四种向页面传输变量的方法。

       接下来我们学习 变量的替换


   ##########################################################


       5、第一种视图输出字符串内容替换的方法： 
                                
            在 app\index\controller\Index.php中 使用 fetch（）函数的第三个参数进行 ‘视图输出字符串内容替换’ 到 .html 文件，如下 ：

                      namespace app\index\controller;
                      use think\View;
                      use think\Controller;
                      class Index extends Controller{

                           public function index(){

                                return $this->fetch('index', [],[

                                  'STATIC' => '这是static替换后的内容'
                                ]
                              );
                           }
                      } 

            访问：http://localhost/think_web/public/index/index/index

            在view/index 目录下 index.html 文件中 使用花括号进行变量输出,如下：

				<!DOCTYPE html>
				<html lang="en">
				<head>
					<meta charset="utf-8">
					<title>Document</title>
				</head>
				<body>
				   <h1>这里是 index.html  这是在 view/index 目录下</h1>
				   <p>STATIC</p>
				</body>
				</html>



       6、第二种视图输出字符串内容替换的方法:

              我们可以在配置文件中统一设置 视图输出字符串内容替换。

              将 惯例配置convention.php 中的   'view_replace_str' => [],  复制到 应用配置config.php文件中，如下:

               //视图输出字符串内容替换
 
                'view_replace_str' => [
                
                    'STATIC2' => '这是static2替换后的内容',
                     'STATIC3' => '这是static3替换后的内容'
                ], 

            访问：http://localhost/think_web/public/index/index/index

            在view/index 目录下 index.html 文件中 使用花括号进行变量输出,如下：

				<!DOCTYPE html>
				<html lang="en">
				<head>
					<meta charset="utf-8">
					<title>Document</title>
				</head>
				<body>
				   <h1>这里是 index.html  这是在 view/index 目录下</h1>
				   <p>STATIC</p>
                                   <p>STATIC2</p>
                                   <p>STATIC3</p>
				</body>
				</html>

            页面显示如下：

                          这里是 index.html 这是在 view/index 目录下

                          这是static替换后的内容

                          这是static2替换后的内容

                          这是static3替换后的内容



      7、另外我们还有系统默认的一些字符串替换：

         如： ‘__URL__’   --> 页面显示为： /think_web/public/index/index （这个是当前访问路径）

              ‘__STATIC__’   --> 页面显示为： /think_web/public/static (这个是public\static目录，是用来放置静态文件的，例如 css样式，js脚本，如果我们用直接引入的方式，后期调整会比较复杂 ，所以一般会用 ‘__STATIC__’来对应 public\static目录)

              ‘__JS__’   --> 页面显示为： /think_web/public/static/js （这个是public\static\js目录，是用来放置js文件的，）

              ‘__CSS__’   --> 页面显示为： /think_web/public/static/css （这个是public\static\css目录，是用来放置css文件的，）

               '__ROOT__'  --> 页面显示为： /think_web/public


      例子：以 ‘__CSS__’作为例子：

               app\index\view\index\index.html 中 如果我们想引入 style.css文件:

                 原本的代码： <link rel="stylesheet" type="text/css" href="/think_web/public/static/css/style.css">

                 如果我们使用'__CSS__'，即为：<link rel="stylesheet" type="text/css" href="__CSS__/style.css">   


            用'__CSS__'做 css文件引入的路径的优点：

                    当我们不想把css文件放static\css目录中是， 而是想把css文件放在 static的同级目录front目录中的css目录中时，

                       如果按照原来的引入方法， 我们就需要修改大量的.html文件的 href路径，

                       但是如果我们使用了 '__CSS__'，我们就可以在应用文件config.php 配置字符串替换：

                             'view_replace_str' => [
                      
                                   '__CSS__' => '/think_web/public/front/css'
                              ],                    

                       这样子，我们只要使用字符串替换修改一个地方，就可以修改所有的文件了。这样对后期维护是十分方便的





-------------------------------------------------------------------------------------------------------------------------------------------

 5-3 系统变量原生标签 (10:56)

        （1） $_SERVER 系统变量 在模板( 即.html文件 )中使用 例如{ $Think.server.HTTP_HOST }，我们可以在这之前使用 dump($_SERVER),打印看看$_SERVER中有哪些变量。


        （2） 获取.env的系统变量 在模板( 即.html文件 )中使用 例如{ $Think.env.PHP_STATUS }，

                    注意.env文件中，我们配置的内容是 “status=dev” ，但是我们在模板.html文件中获取时用的却不是 “{ $Think.env.status }”，而是“{ $Think.env.PHP_STATUS }”， 因为系统会自动给 .env中的变量加 ‘PHP_’前缀，并且变为大写。


        （3） 获取session中的参数值。

                   首先在 index.php中 添加 session('email', '1095654362@qq.com'); 

                   然后刷新http://localhost/think_web/public/index/index/index， 确保 ‘email’及其值有保存在session中。

                   在模板( 即.html文件 )中使用 { $Think.session.email } 就可以获取 ‘email’的值。


        （4） 获取cookie中的参数值。

                   首先在 index.php中 添加 cookie('name', 'arvin'); 

                   然后刷新http://localhost/think_web/public/index/index/index， 确保 ‘name’及其值有保存在cookie中。

                   在模板( 即.html文件 )中使用 {$Think.cookie.name} 就可以获取 ‘name’的值。


        （5） 获取get中的参数值。

                   然后刷新http://localhost/think_web/public/index/index/index?id=15，

                   在模板( 即.html文件 )中使用 {$Think.get.id} 就可以获取 ‘id’的值，输出为15。       


        （6） 获取request中的参数值。

                   然后刷新http://localhost/think_web/public/index/index/index?id=15，

                   在模板( 即.html文件 )中使用 {$Think.request.id} 就可以获取 ‘id’的值，因为request中包含get中的所有值，所以也会输出为15


        （7） 获取post中的参数值。

                   然后刷新http://localhost/think_web/public/index/index/index

                   在模板( 即.html文件 )中使用 {$Think.post.XXXX} 就可以获取 ‘XXXX’的值

                   这里的例子使用 postman 来做测试。

                      在postman中 访问 http://localhost/think_web/public/index/index/index，

                            设置传输方式为‘post’，并选择‘body’，再添加 key 为 ‘user’， value 为 '阿本'，

                      在模板( 即.html文件 )中使用 {$Think.post.user} 就可以获取 ‘user’的值，输出为‘阿本’



        （8） 获取常量值。

                   然后刷新http://localhost/think_web/public/index/index/index，

                   在模板( 即.html文件 )中使用 {$Think.const.APP_PATH} 就可以获取常量当前应用所在的目录。

                       输出为： D:\xampp\htdocs\think_web\public/../app/    

                                     这里的意思是指在 应用所在的目录在 public的同级目录app目录下。 

                 获取系统常量有两种方式：

                      ①、 {$Think.const.APP_PATH}

                      ②、 {$Think.APP_PATH}
  
                               两种方式的输出结果是一样的。


         ================================================

             接下来我们学习下模板文件.html文件中，如何使用原生的php标签：

                 我们可以在模板文件.html文件中直接内嵌 <?php  ....   ?>  的内容，如下

		<!DOCTYPE html>
		<html lang="en">
		<head>
		<meta charset="utf-8">
		<title>Document</title>
		<!-- <link rel="stylesheet" type="text/css" href="__CSS__/style.css"> -->
		</head>
		<body>
		   <h1>这里是 index.html  这是在 view/index 目录下</h1>
                   <p>{$Think.server.HTTP_HOST}</p>
                   <P>{$Think.env.PHP_STATUS}</P>
                   <p>{$Think.session.email}</p>
                   <p>{$Think.cookie.name}</p>
                   <p>{$Think.get.id}</p>
                   <p>{$Think.request.id}</p>
                   <p>{$Think.post.user}</p>
                   <p>{$Think.const.APP_PATH}</p>
                   <p>{$Think.APP_PATH}</p>
                   <?php
                           echo APP_PATH . '<br>';
                           $a = 10;
                           $b = 20;
                           if($a > $b){
                                echo '1';
                            }else{
                                echo '2';
                            }
                   ?>
				</body>
				</html>                    

                  注意： 虽然我们可以这样写，但是一般不建议在模板文件.html文件中直接内嵌 <?php  ....   ?> 这种原生php标签，如果我们有一些逻辑比较复杂的时候，我们应该优先考虑调整我们的控制器，大多数的逻辑需要在我们的控制器中完成，我们的模板只是用来展示我们的界面，而一般不用来编写逻辑。


            =====================================================

               总结：

                    模板中可以直接使用系统框架提供的$Think变量，获取来自系统中所有变量的值

                    模块还支持直接写入php原生代码，但是对维护不利，建议不使用此类操作(在模板中使用原生PHP标签：<?php ?>直接在里面和之前一样写php代码即可。可以使用模板变量，系统变量。但是不建议使用原生，混编维护起来复杂。大多数逻辑在控制器完成。)

                    在模板中获取常量：{$Think.const.APP_PATH} 或者 {$Think.APP_PATH}，两种方式均可;
 
                    注意.env必须加上PHP_前缀，并且所有字母大写




-------------------------------------------------------------------------------------------------------------------------------------------

 5-4 变量输出 调节器 (14:57)

      上节课我们学习了在模板中怎么输出变量以及如何使用我们的系统变量，这节课我们学习如何在模板.html文件中进行变量的调整，比如说我们想在模板中进行一些运算，以及对变量的一些特殊的处理。

       1、模板变量：

             例子： 

                 首先我们用 $this->assign()向模板传输一些变量：

            在 app\index\controller\Index.php内容如下 ：

                      namespace app\index\controller;
                      use think\View;
                      use think\Controller;
                      class Index extends Controller{

                           public function index(){

                              $this->assign('email', '1095654362@qq.com');

                              $this->assign('time', time());  //时间戳
        
                              $this->assign('user', 'arvin');

                              return $this->fetch();
                           }
                      }                
   

            在view/index 目录下 index.html 文件中：

				<!DOCTYPE html>
				<html lang="en">
				<head>
					<meta charset="utf-8">
					<title>Document</title>
					<!-- <link rel="stylesheet" type="text/css" href="__CSS__/style.css"> -->
				</head>
				<body>
				   <h1>这里是 index.html  这是在 view/index 目录下</h1>
              （1）、
                   <h2>{$email} : {$email|md5}</h2> 

                            <!--  //‘{$email|md5}’ 表示将 email的值进行md5编码，并输出，输出结果为：1095654362@qq.com : 643aa1771448a6978a603c26445522f8 一般md5的使用方法为 : md5($obj) , -->


              （2）、
                   <h2>{$email} : {$email|substr=0,8}</h2> 

                            <!-- // '{$email|substr=0,8}'表示截取 $email的值的前八位字符串，并输出，输出结果为：1095654362@qq.com : 10956543 0表示从下标为0的字符开始截取，8表示截取8位字符串  一般substr的使用方法为 : substr($obj,0,3) , 但这模板中写成‘{$email|substr=1,8}’ -->

                <!--  注意：类似以上的md5()方法和substr()方法，他们的第一个参数都是填入我们需要改变的变量，所以在模板中使用时，‘{$email|md5}’或者‘{$email|substr=1,8}’ 就不用再次填入我们需要改变的变量。 系统会自动调用前面的变量作为第一个参数。 -->


              （3）、
                    <h2>{$time} : {$time|date="Y-m-d", ###}</h2>

                            <!--  一般substr的使用方法为 : date("Y-m-d",time());  date()方法的第二个参数才是我们填入要需要修改的变量，所以我们在模板使用date函数时，使用'###'井号进行占位，{$time|date="Y-m-d", ###}  输出结果为：1553429342 : 2019-03-24-->
 

              （4）、
                     <h2>{$email} : {$email|substr=###,0,8}</h2>

                            <!--  {$email|substr=###,0,8} 的效果和 {$email|substr=0,8} 是一样的，只是因为类似以上的md5()方法和substr()方法，他们的第一个参数都是填入我们需要改变的变量，所以我们可以忽略不屑'###'占位符 -->


              （5）、
                      <h2>{$email} : {$email|md5}：{$email|md5|strtoupper}</h2>

                             <!-- {$email|md5|strtoupper} 这里使用了连续两个函数进行了处理，表示先将 $email值进行md5加密，然后再将加密后的结果转成大写 -->



              （6）、接下来看变量在模板.html文件中的计算 ： 在模板中，我们用以下例子的方法进行加减乘除等运算是可以的。

                       首先我们用 $this->assign()向模板传输 a变量、 b变量、c变量：

                          在 app\index\controller\Index.php内容如下：

                                                   $this->assgin('a',10);

                                                   $this->assgin('b',20);

                       在view/index 目录下 index.html 文件中：

	                      <p>a + b = {$a + $b}</p>
	                      <p>a - b = {$a - $b}</p>
	                      <p>a * b = {$a * $b}</p>
	                      <p>a / b = {$a / $b}</p>
	                      <p>b % a = {$b % $a}</p>
	                      <p>a + b * c = {$a + $b * $c}</p>
	                      <p>a++ = {$a++}</p>
	                      <p>a-- = {$a--}</p>


                       输出结果为：

                                 a + b = 30
                                 a - b = -10
                                 a * b = 200
                                 a / b = 0.5
                                 b % a = 0
                                 a + b * c = 110
                                 a++ = 10
                                 a-- = 11

                             注意： 这里需要特别注意的是， a++ 和 a-- 运算的是同一个变量，所以 'a++' 的运算结果会影响到 'a--'


              （7）、当我们没有在‘app\index\controller\Index.php’中定义某个变量时，我们还可以使用thinkphp内置的一个函数 ‘default函数’ 在模板中直接对变量进行定义。
 
                     比如： <h2>{$name|default='arvin'}</h2>    ，

                                 我们直接在模板.html文件中定义变量‘$name’的值。

                     注意：

                            如果我们在 app\index\controller\Index.php 中 定义了  

                                  $this->assign('name','阿本')，

                            同时在模板.html文件中定义变量‘$name’的值：

                                   <h2>{$name|default='arvin'}</h2

                            则模板中设置的默认值‘arvin’无效， 页面会输出 ‘阿本’



               （8）、 在模板中直接输出类似 '{$email}' 这种字符串

                            如果我们在 app\index\controller\Index.php 中 定义了  

                                  $this->assign('$email','1095654362@qq.com')，

                            那么我们在模板.html中文件中，写入代码 {$email} ,那么在页面中显示的是 '1095654362@qq.com'

                            但是如果我们想直接在页面显示字符串 ‘{$email}’, 可以用 {literal}{/literal}标签

                            比如：
                                  {literal}
                                      {$email}
                                  {/literal}
                                             
                                这样子，我们就能在页面中，直接输出字符串'{$email}'  

                                在{literal}{/literal}中的内容，系统是不会去进行编译的。


               （9）、在模板中进行注释

                         如果我们在模板.html文件中 使用 <!--。。。--> 来进行注释时，

                             虽然不会在页面中显示，但是我们在查看页面的源代码时，还是可以看得到这些注释的， 


                         如果我们用 {/*。。。*/} 来进行注释时，系统就会编译成php的注释， 则既在页面中不会显示，用户在浏览器查看源代码时，也不会看到有这些注释            


                         html注释用户可见

                         但是用php的注释方法 前端源码是看不见的 可以放心的写注释

                 ###用于占位，若为第一位可以省略，变量调节器支持管道模式

				</body>
				</html>




             
-------------------------------------------------------------------------------------------------------------------------------------------


 5-5 模板循环标签 (18:02)

        有三种循环标签

        首先在 app\index\controller\Index.php 中 定义 一个二维数组‘$list’,

          如下：
                      namespace app\index\controller;
                      use think\View;
                      use think\Controller;
                      class Index extends Controller{

                           public function index(){

                                $list = [

                                    'user1' => [
                                      'name' => 'imooc',
                                      'email' => 'imooc@qq.com'
                                    ],

                                    'user2' => [
                                      'name' => '1095654362',
                                      'email' => '1095654362@qq.com'
                                    ],

                                    'user3' => [
                                      'name' => 'arvin',
                                      'email' => 'arvin@qq.com'

                                    ]
                                ];

                                $this->assign('list', $list);

                                return $this->fetch();
                           }
                      }  



           （1）第一种循环标签  {volist} ....{/volist}

                            {volist name="list" id="data" offset="2" length="1" mod="3"  empty="$empty" }

                               <p>{$mod}</p>
                               <p>{$data.name}</p>

                            {/volist}


                页面显示结果(最初的输出结果)：

                                    imooc

                                    1095654362

                                    arvin


               解析1： name="list", 这里的‘list’就是我们从控制器传出过来的 二维数组‘list’

                      id="data" 指的是 迭代器，也就是遍历中的value值
 
                      offset="2" offset设置从下标为2的value开始遍历，  默认为offset="0"

                                   如果这里设置了 offset="2" , 页面显示结果只有：arvin 

                      length="1" length指的是当前循环要循环多少次， length="1"则表示该循环只循环一次， 即只输出一个结果 "imooc"

                      mod 指的是对当前循环次数进行取余， mod="3"则表示每次循环时，当前的循环次数都对 3 进行取余。利用 “<p>{$mod}</p>”，来进行输出。

                      empty 指的是当 $list为空的时候，即“$list = [];”，会输出empty所设置的值

                          empty需要注意的地方：

                               我们不能直接在 empty 中使用html标签，即不能用这样的代码： empty="<h1>这里没有数据，并且使用了h1标签<h1>" 

                               但是我们可以在empty中使用变量，所有我们可以通过传送变量在 empty 中使用 html标签。如下：

                               ①在控制器中用$this->assign()函数进行传输：

                                     $this->assign('empty','<h1>这里没有数据，并且使用了h1标签<h1>');
 
                                     在模板中的 {volist}循环标签中利用  empty="$empty"  进行显示。

 
                                ②、第二种方式： （在模板中直接使用原生php,一般是不建议使用的）

                                      可以在模板.html文件中使用原生php标签定义 $empty的值，如下：

                                         <?php
                                               $empty="<h1>这里没有数据，并且使用了h1标签<h1>";
                                         ?>

                                     在模板中的 {volist}循环标签中利用  empty="$empty"  进行显示。


                                ③、第三种方式： 在模板.html文件中使用系统内置的php标签{php}{/php}进行 变量的定义， 如下：

                                         {php}
                                              $empty = "<h1>这里没有数据，并且使用了h1标签<h1>";
                                          {/php}

                                     在模板中的 {volist}循环标签中利用  empty="$empty"  进行显示。

               解析2： 

                       在{volist}标签中还有 一个变量“{$i}”, 表示当前是第几次循环， 

                          模板中代码： <p>{$i}</p>

                       如果 默认的{$i} 和我们自己的代码起冲突，我们可以在{volist}的标签中，利用 key = "xxx",来修改变量 i 的 变量名。



               ###################################


           （2）第二种循环标签   foreach 标签 

                   foreach 标签 在模板中的写法与我们在原生的php中的写法类似

                     ①foreach的第一种写法：

                          {foreach $list as $ov}

                              <p>{$ov.name} : {$ov.email}</p>

                          {/foreach}  


                     ②foreach的第二种写法：

                          {foreach name="list" item="ov"}

                              <p>{$key} :{$ov.name} : {$ov.email}</p>

                          {/foreach}  
                          

                          页面显示结果为：
                                            user1 : imooc : imooc@qq.com

                                            user2 : 1095654362 : 1095654362@qq.com

                                            user3 : arvin : arvin@qq.com

                           foreach标签中，有一个默认的变量$key， 指的是数组的下标， 在这里 $key 输出分别为下标user1、user2、user3

                           我们也可以自定义变量$key的变量名，如下    

                                        {foreach name="list" item="ov" key = "s"}

                                              <p>{$s} :{$ov.name} : {$ov.email}</p>

                                         {/foreach}  



           （1）第三种循环标签 for标签  {for} ....{/for}

                 ① for标签在模板.html中使用的小例子：

                          {for start='1' end = '10' }

                              <p>{$i}</p>

                          {/for}

                  页面显示结果为：
                                    1
                                    2
                                    3
                                    4
                                    5
                                    6
                                    7
                                    8
                                    9
                     
                  以上代码，编译为php代码，如下：
       
                       for( $i=1; $i<10; i++ ){

                           echo "<p>{$i}</p>";
                       }


                 ② 在①的基础上修改，如果我们每次 变量i 都想加 2 ，可以设置 step的值为2， 如下：

                          {for start='1' end = '10' step="2" }

                              <p>{$i}</p>

                          {/for}

                      页面显示结果为：
                                    1
                                    2
                                    3
                                    4
                                    5
                                    6
                                    7
                                    8
                                    9
                     
                      以上代码，编译为php代码，如下：
       
                            for( $i=1; $i<10; $i+=2 ){

                                   echo "<p>{$i}</p>";
                            }


                 ③ 在①②的基础上修改，想修改变量 i 的变量名，可以设置 name = "k" ,  如下：

                          {for start='1' end = '10' step="2" }

                              <p>{$k}</p>

                          {/for}

                      页面显示结果为：
                                    1
                                    2
                                    3
                                    4
                                    5
                                    6
                                    7
                                    8
                                    9
                     
                      以上代码，编译为php代码，如下：

                            for( $i=1; $i<10; $k+=2 ){

                                   echo "<p>{$k}</p>";
                            }


                      注意： 如果我们还有代码 “<p>{$k}</p>”， 这会报错： 未定义变量: i




-------------------------------------------------------------------------------------------------------------------------------------------


 5-6 比较标签 (10:45)

      以下是 thinkphp内置的一些比较标签：

       1、{eq} 比较标签

            首先在控制器index.php文件中，设置 变量a=10, b=20 :

                    namespace app\index\controller;
                      use think\View;
                      use think\Controller;
                      class Index extends Controller{

                           public function index(){
                               
                                $this->assign('a', 10);
                                $this->assign('b', 20);
                                return $this->fetch();
                           }
                      }  



            然后在模板.html文件中使用{eq}标签

		<body>
		<h1>这里是 index.html  这是在 view/index 目录下</h1>

                   <!-- eq equal -->

                   {eq name='a' value='10'}

                         <p>相等</p>

                   {else/}

                         <p>不相等</p>

                   {/eq}

		</body>
		</html>

                解释：  name='a' 表示取变量a的值，

                        value=‘10’， 则是判断a的值是否等于 10， 若等于，则执行代码‘<p>相等</p>’，若不相等，则执行代码‘<p>不相等</p>’


      2、{equal} 比较标签: 使用方法与 {eq}完全一样，即equal标签相当于是 eq标签的别名。


                   {equal name='a' value='10'}

                         <p>相等</p>

                   {else/}

                         <p>不相等</p>

                   {/equal}



      3、{neq}以及同名标签{notequal}  ：  由名称可知，这两个标签的性质与 {eq}标签以及{equal}是完全相反的。

           例子：
                   {neq name='a' value='10'}

                         <p>不相等</p>

                   {else/}

                         <p>相等</p>

                   {/neq}


            解释：  当判断为false时， 将会输出前面部分，即执行代码“<p>不相等</p>”， 

                    当判断为true时，将会输出后面部分，即执行代码“<p>相等</p>”。

                    {notequal} 标签与{neq} 标签一样。


       以上是判断是否相等的标签。
 
        #########################################


     4、{gt}标签 ： 判断是 变量值XX 是否大于（不包括等于）我们设置的value值。

         例子：
                   {gt name='a' value='10'}

                         <p>正确</p>

                   {else/}

                         <p>错误</p>

                   {/gt}


                解释：  name='a' 表示取变量a的值，

                        value=‘10’，则是判断a的值是否大于(不包括等于) 10， 若大于（true），则执行前面部分代码‘<p>正确</p>’，若不大于（false），则执行后面部分代码‘ <p>错误</p>’


     5、{egt}标签 ： 判断是 变量值XX 是否大于等于（包括等于）我们设置的value值。

         例子：
                   {egt name='a' value='10'}

                         <p>正确</p>

                   {else/}

                         <p>错误</p>

                   {/egt}


                解释：  name='a' 表示取变量a的值，

                        value=‘10’，则是判断a的值是否大于等于 10， 若大于等于（true），则执行前面部分代码‘<p>正确</p>’，若不大于等于（false），则执行后面部分代码‘ <p>错误</p>’



     6、{lt}标签 ： 判断是 变量值XX 是否小于我们设置的value值。

         例子：
                   {lt name='a' value='10'}

                         <p>正确</p>

                   {else/}

                         <p>错误</p>

                   {/lt}


                解释：  name='a' 表示取变量a的值，

                        value=‘10’，则是判断a的值是否小于(不包括等于) 10， 若小于（true），则执行前面部分代码‘<p>正确</p>’，若不小于（false），则执行后面部分代码‘ <p>错误</p>’


     7、{elt}标签 ： 判断是 变量值XX 是否小于等于（包括等于）我们设置的value值。

         例子：
                   {elt name='a' value='10'}

                         <p>正确</p>

                   {else/}

                         <p>错误</p>

                   {/elt}


                解释：  name='a' 表示取变量a的值，

                        value=‘10’，则是判断a的值是否小于等于 10， 若小于（true），则执行前面部分代码‘<p>正确</p>’，若不小于等于（false），则执行后面部分代码‘ <p>错误</p>’



     8、在比较标签的value值，我们不仅可以使用常数， 我们还可以使用变量。

          例如：

            在模板.html文件中使用{eq}标签，其中 value值 我们传送一个变量‘b’来代替

		<body>
		<h1>这里是 index.html  这是在 view/index 目录下</h1>

                   <!-- eq equal -->

                   {eq name='a' value='$b'}

                         <p>相等</p>

                   {else/}

                         <p>不相等</p>

                   {/eq}

		</body>
		</html>

                解释：  name='a' 表示取变量a的值，

                        value=‘$b’： 则是判断a的值是否等于 变量$b的值， 若等于，则执行代码‘<p>相等</p>’，若不相等，则执行代码‘<p>不相等</p>’


       额外笔记：

             在比较标签中，value值可以使用我们自己分配的变量，也可以使用thinkphp系统常量，或者说是我们配置中的常量等等可以使用的。

             和变量比较的时候，value="$b",需加$

             else是取反，一定要加斜杠


-------------------------------------------------------------------------------------------------------------------------------------------

 5-7 条件判断标签 (15:01)

      1、{switch}标签

           例子：
 
              模板中的内容：

		<!DOCTYPE html>
		<html lang="en">
		<head>
			<meta charset="utf-8">
			<title>Document</title>			
		</head>
		<body>
		   <h1>这里是 index.html  这是在 view/index 目录下</h1>

                   <!-- switch -->
                   {switch name = "Think.get.level"}
                        {case value='1'} <p>普通会员</p> {/case}
                         {case value='2'} <p>铜牌会员</p> {/case}
                          {case value='3'} <p>金牌会员</p> {/case}
                           {case value='4|5'} <p>钻石会员</p> {/case}
                            {default /}<p>游客</p>
                   {/switch}
		</body>
		</html>

            访问并传参level=1 ：http://localhost/think_web/public/index/index/index?level=1

                显示结果： 
                             这里是 index.html 这是在 view/index 目录下
                             普通会员

            解析： 这里传参level值，当 level的值为： 1，2，3，4 时，会返回显示相应的会员

                   当level的值不在 1，2，3，4 的范围内容： 则会显示 游客。

                   value='4|5' 表示： level的值是 4 或者 5 的时候，都会输出 钻石会员。


      2、{range}标签

           （1）例子：type="in" 时
                   {range name="Think.get.level" value="1,2,3" type="in"}

                         <p>当前level是1，2，3中的一个</p>

                   {else/}

                         <p>当前level不是1，2，3中的一个</p>

                   {/range}

                解析： 当 type = "in" 时,

                            会对level的值进行判断，如果 level是1，2，3中的一个 ，则执行代码” <p>当前level是1，2，3中的一个</p>“       
                                       
                                                   如果 level不是1，2，3中的一个 ，则执行代码” <p>当前level不是1，2，3中的一个</p>“ 

             ##################################################

                {in}标签：

                   {in name="Think.get.level" value="1,2,3" }

                         <p>当前level是1，2，3中的一个</p>

                   {else/}

                         <p>当前level不是1，2，3中的一个</p>

                   {/in}

                解析： 
                       会对level的值进行判断，如果 level是1，2，3中的一个 ，则执行代码” <p>当前level是1，2，3中的一个</p>“       
                                       
                                              如果 level不是1，2，3中的一个 ，则执行代码” <p>当前level不是1，2，3中的一个</p>“ 


                注意： {in}标签 与 当type="in"时的 {range type="in"}标签 的效果是一样的

             ###################################################

           （2）例子：type="notin" 时
                   {range name="Think.get.level" value="1,2,3" type="notin"}

                         <p>当前level不是1，2，3中的一个</p>

                   {else/}

                         <p>当前level是1，2，3中的一个</p>

                   {/range}

                解析： 当 type = "notinin" 时,

                        会对level的值进行判断，如果 level不是1，2，3中的一个 ，则执行前面部分代码” <p>当前level不是1，2，3中的一个</p>“   
                                       
                                               如果 level是1，2，3中的一个 ，则执行后面部分代码” <p>当前level是1，2，3中的一个</p>“

             ##################################################

                {notin}标签：

                   {notin name="Think.get.level" value="1,2,3" }

                         <p>当前level不是1，2，3中的一个</p>

                   {else/}

                         <p>当前level是1，2，3中的一个</p>

                   {/notin}

                解析： 
                       会对level的值进行判断，如果 level不是1，2，3中的一个 ，则执行代码” <p>当前level不是1，2，3中的一个</p>“       
                                       
                                              如果 level是1，2，3中的一个 ，则执行代码” <p>当前level是1，2，3中的一个</p>“ 


                注意： {notin}标签 与 当type="notin"时的 {range type="notin"}标签 的效果是一样的

             ###################################################


      （3）例子：type="between" 时 : 表示判断当前的值 是否在我们设置的区间中

                   {range name="Think.get.level" value="1,10" type="between"}

                         <p>当前level的值在1至10之间</p>

                   {else/}

                         <p>当前level的值不在1至10之间</p>

                   {/range}


                   解析： 当type="between" 时， value值只接受两个参数，如： value="1,10"

                            当 level的值在1至10之间（包含 1 和 10） 时，则执行前面部分代码： “<p>当前level的值在1至10之间</p>”
 
                            当 level的值不在1至10之间 时，则执行后面部分代码： “<p>当前level的值不在1至10之间</p>”


           ######################################################


           {between name="Think.get.level" value="1,10"}

                  <p>当前level的值在1至10之间</p>

             {else/}

                   <p>当前level的值不在1至10之间</p>          
           {/between}


            注意： {between}标签 与 当type="between"时的 {range type="between"}标签 的效果是一样的

           ######################################################
           


      （4）例子：type="notbetween" 时 ：表示判断当前的值 是否不在我们设置的区间中

                   {range name="Think.get.level" value="1,10" type="notbetween"}

                         <p>当前level的值不在1至10之间</p>

                   {else/}

                         <p>当前level的值在1至10之间</p>

                   {/range}


                   解析： 当type="notbetween" 时， value值只接受两个参数，如： value="1,10"

                            当 level的值不在1至10之间 时，则执行前面部分代码： “<p>当前level的值不在1至10之间</p>”
 
                            当 level的值在1至10之间（包含 1 和 10） 时，则执行后面部分代码： “<p>当前level的值在1至10之间</p>”


           ######################################################


           {notbetween name="Think.get.level" value="1,10"}

                  <p>当前level的值在1至10之间</p>

             {else/}

                   <p>当前level的值不在1至10之间</p>          
           {/notbetween}


            注意： {notbetween}标签 与 当type="notbetween"时的 {range type="notbetween"}标签 的效果是一样的

           ######################################################



      3、第三个标签： {defined}标签  : 判断某个常量是否已经定义

           例子：

                   {defined name="APP_PATH"}

                      <p>APP_PATH已经定义</p>

                   {else/}

                      <p>APP_PATH未定义</p>

                   {/defined}                    


             解析: 以上例子是判断我们系统中是否定义了 APP_PATH 这个常量， 因为我们确实定义了 APP_PATH这个常量，所以以上会执行前面部分代码：

“<p>APP_PATH已经定义</p>”。

                   如果我们修改成 name="APP_PATH_NO" ， 我们没有定义 APP_PATH_NO 这个常量，所以会执行后面的代码“<p>APP_PATH未定义</p>”



     4、第四个标签： {if} 标签 

            在我们的模板中， 一般不建议使用{if} 标签，因为在我们的模板中进行大量的判断，是有问题的，让我们的模板变得不够干净，如果我们想使用判断，一般使用{switch}标签就可以了。

            如果我们需要使用 if 的话，可以检查我们的控制器，如果我们的模板中存在大量的if， 说明我们的控制器编写有问题。


            以下是使用 {if}标签 的例子：

                   {if condition = "($Think.get.level == 1) AND ($Think.get.id == 10)"}

                       <p>当前的level值为1， 并且id的值为10</p>

                   {else/}

                         <p>当前的level值不为1或者id的值为10</p>

                    /if}


             解析：当 condition 中的语句 “($Think.get.level == 1) AND ($Think.get.id == 10)” 为true时，会执行前面部分代码“<p>当前的level值为1， 并且id的值为10</p>”

                   当 condition 中的语句 “($Think.get.level == 1) AND ($Think.get.id == 10)” 为false时，会执行后面部分代码“<p>当前的level值不为1或者id的值为10</p>”





-------------------------------------------------------------------------------------------------------------------------------------------


 5-8 模板的布局 包含和继承 (27:46)


         1、当控制器的代码如下时：

                    namespace app\index\controller;
                      use think\View;
                      use think\Controller;
                      class Index extends Controller{

                           public function index(){

                                return $this->fetch();
                           }

                           public function page1(){

                                return $this->fetch();
                           }
                      } 

           我们去访问 ：http://localhost/think_web/public/index/index/page1

           页面显示的模板.html文件为：app\index\view\index\page1.html, 即是index模块下的和控制器同级目录view目录下的 index\page1.html模板。


      2、{include}标签  ： include机制，即模板引入机制

           例子：

                 但我们的模板index.html 和模板page1.html 拥有相同的代码时， 如果我们想去修改这段相同的代码，即每次都需要修改模板index.html 和模板page1.html这两个文件，这样将非常麻烦。

                 所有我们可以在view目录下创建一个common目录，并在common目录下再创建一个nav.html文件，将模板index.html 和模板page1.html 相同的代码复制到 nav.html文件 中， 如：

                     nav.html文件的内容：                  
						<ul class="nav">
						  <li><a href="">菜单01</a></li>
						  <li><a href="">菜单02</a></li>
						  <li><a href="">菜单03</a></li>
						  <li><a href="">菜单04</a></li>
						</ul>


                 然后我们在模板index.html 和模板page1.html中利用{include}标签 就可以引入这段相同的代码，如下

                   	  <!-- 头部 -->
                   	  <div class="header">
                   	  	 {include file="common/nav" /}     //这里即是引入相同的代码，这样修改起来就比较方便了。
                   	  </div>

                使用<include>标签后，我们就只需修改 nva.html文件， 引入nva.html的其他文件也就跟着改变，就不用一个一个去修改。



      3、模板继承{extend /}  ： 继承机制

               在模板.html页面中，我们一般不会去修改头部，一般我们修改的是<body>这一部分。

               首先我们在index模块下的view/common目录下新建一个base.html文件，让所有模板都继承这个文件, 

               将原本在模板index.html的所有代码全部复制粘贴在 base.html 文件中，然后将模板index.html文件的代码全部删除。

               再将 代码 “{extend name="common/base" /}” 复制到 模板index.html文件中 ，
  
               我们去访问 ：http://localhost/think_web/public/index/index/index, 

               页面还是会显示原来的东西。

            
               注意： 如果我们将模板index.html文件和模板page1.html文件中的内容全部删除, 全部改成“{extend name="common/base" /}”，

                      这样子，两个模板显示的页面是完全一样的额，连title也是一样的，这显然不是我们想要的。


          在base.html文件中使用 {block}标签，使我们的不同模板在继承base.html文件的同时，可以根据每个模板的需要，修改不一样的地方

          比如 每个模板的title 是不一样的，我们可以根据以下例子看怎么显示每个模板不同的title：

                  首先在 base.html文件的title标签中使用 {block}标签，如：
        
 				<head>
					<meta charset="utf-8">
					<title>
						{block name="title"}
					       模板学习 ThinkPHP5 index页
						{/block}}
					</title>
					<link rel="stylesheet" type="text/css" href="__CSS__/style.css">
				</head>


                 然后修改模板文件page1的内容，也使用 {block}标签：

                                    {extend name="common/base" /}

                                    {block name="title"}

                                       模板学习 ThinkPHP5 page1页

                                    {/block}}

                 这样，我们去访问
 
                    http://localhost/think_web/public/index/index/index,  和 http://localhost/think_web/public/index/index/page1,
                 
                 就会发现他们页面的 title 不一样



            例子2： 

                  我们给base.html的<body></body>中也添加 {block}标签

                     修改成：

                          <div class="body">
                          	 {block name="body"}

                          	 {/block}
                          </div>


                  然后修改模板index.html如下： 

                             {extend name="common/base" /}

                             {block name="body"}
                                  <h1>这里是模板index.html页面的body区域页面</h1>
                             {/block} 


                  再修改模板page1.html如下： 

                             {extend name="common/base" /}

                             {block name="title"}
                                 模板学习 ThinkPHP5 page1页
                             {/block}}

                             {block name="body"}
                                  <h1>这里是模板page1.html页面的body区域页面</h1>
                             {/block} 


                 这样，我们去访问
 
                    http://localhost/think_web/public/index/index/index,  和 http://localhost/think_web/public/index/index/page1,
                 
                 就会发现他们页面的 body区域 的内容是不同的。



          例子3：使用{block}标签时，我们有时候是不需要覆盖掉base.html中的全部内容的，而是要和base.html的内容相结合。

                 这时候就要使用到 {__block__}如下：


                  首先我们给base.html的footer区域中也添加 {block}标签

                     修改成：

                          <div class="footer">
                          	 {block name="footer"}
                                       footer
                          	 {/block}
                          </div>

 
                   然后修改模板index.html如下： 

                             {extend name="common/base" /}

                             {block name="body"}
                                  <h1>这里是模板index.html页面的body区域页面</h1>
                             {/block} 

                             {block name="footer"}
                                  <h1>index_{__block__}}</h1>
                             {/block}

                        
                   再修改模板page1.html如下： 

                             {extend name="common/base" /}

                             {block name="title"}
                                 模板学习 ThinkPHP5 page1页
                             {/block}}

                             {block name="body"}
                                  <h1>这里是模板page1.html页面的body区域页面</h1>
                             {/block} 
                      
                             {block name="footer"}
                                  <h1>page1_{__block__}}</h1>
                             {/block}
                 
                 这样，我们去访问
 
                    http://localhost/think_web/public/index/index/index,  和 http://localhost/think_web/public/index/index/page1,
                 
                 就会发现  index.html 和  page1.html的footer区域 与 base.html的footer区域的内容相结合，

                   index页面 的footer区域显示： index_ footer

                   page1页面 的footer区域显示： page1_ footer



         4、layout机制

             例子：

                首先我们在 应用配置文件 conf/config.php中的 模板配置'template'中 添加参数

                        'layout_on' => true, //开启layout功能,在所有的模板中都有效

                        'layout_name' => 'layout'  


                将模板index.html文件的代码全部删除，

                访问：http://localhost/think_web/public/index/index/index

                会报错：模板文件不存在:D:\xampp\htdocs\think_web\public/../app/index\view\layout.html


              解析： 如果我们开启了layout，那么我们的 $this->fetch（）方法的默认规则就会发生了变化。

                     它会优先找到 app/index\view\layout.html 这个文件，所以我们需要新建一个 app/index\view\layout.html 文件。

                     layout.html 的文件名要与 我们配置的  'layout_name' => 'layout'  是一致的


             修改：

              将base.html的所有代码复制给 layout.html, 并且删除掉其中的 {block}标签， 因为在layout.html中 {block}是不生效的.

              {include}标签可以保留，还是可以使用

               layout.html原始内容： 


	          <!DOCTYPE html>
	          <html lang="en">
	          <head>
	          <meta charset="utf-8">
			<title>
				{block name="title"}
					模板学习 ThinkPHP5 index页
				{/block}
			</title>
				<link rel="stylesheet" type="text/css" href="__CSS__/style.css">
		   </head>
		   <body>
		   <h1>这里是 index.html  这是在 view/index 目录下</h1>         
                   <div class="wrap">
                   	  <!-- 头部 -->
                   	  <div class="header">
                   	  	 {include file="common/nav" /}
                   	  </div>

                   	  <!-- 中部 -->
                   	  <div class="main">
                   	  	
                          <!-- 边栏 -->
                          <div class="sidebar">
                          	 sidbar
                          </div>

                          <!-- 内容 -->
                          <div class="body">
                                body
                          </div>

                   	  </div>

                   	  <!-- 尾部 -->
                   	  <div class="footer">
                                  footer
                   	  </div>
                   </div>
		   </body>
		   </html>
            

                访问：http://localhost/think_web/public/index/index/index，就不会报错了，有内容显示



               在layout的机制下修改 body区域的内容： 使用{__CONTENT__}

                     
                 修改layout.html的body区域的内容：

                          <!-- 内容 -->
                          <div class="body">
                                {__CONTENT__}
                          </div>


                 修改index.html文件中的全部内容为： 这里是index.html的全部内容


                 这样，我们去访问
 
                    http://localhost/think_web/public/index/index/index, 
                 
                 就会发现  index.html 的 body区域的内容为：

                                 这里是index.html的全部内容

 
            解析：  我们在 index.html 写的内容 会 和 layout.html 中的 {__CONTENT__} 进行替换.

                    由上可知， 如果我们开启了layout功能，我们不需要在模板中去使用{extend}去继承，我们可以去直接输出内容，它实现的效果与{extend}继承类似。 我们在模板中编写的全部内容 会和 layout.html 中的 {__CONTENT__} 进行替换。

                    使用layout功能时，我们就不能在模板文件中使用 {extend}继承，但可以使用引入标签{include}:

                    如下： 我们可以修改index.html的内容为： 

                                      <div>
                                           {include file="common/nav"}
                                      </div>

                         这样我们就可以在index.html再添加一个导航栏



          在以上的基础再去修改每个页面的标题title： 

            我们可以 使用变量， 如下： 

                 修改layout.html的<title>的内容：添加 {$title}变量

					<title>
					       模板学习 ThinkPHP5 {$title}页
					</title>


            然后在我们的控制器中传递{$title}变量:
              
                如在index.php控制器中传递{$title}变量:

                    namespace app\index\controller;
                      use think\View;
                      use think\Controller;
                      class Index extends Controller{

 
                           public function index(){
                                
                                $this->assign('title','index');
                                return $this->fetch();
                           }

                           public function page1(){

                                 $this->assign('title','page1');
                                return $this->fetch();
                           }
                      }   


                 这样，我们去访问
 
                    http://localhost/think_web/public/index/index/index,  和 http://localhost/think_web/public/index/index/page1,
                 
                  两个页面的标题不一样了.



        总结：  继承和layout的效果是类似的，所以一般看个人喜好，进行选择。

                作者一般会使用继承的这种方式，如果是后台的话，会使用layout加继承，如果是前台的话，会使用继承，因为前台的变化比较多.


-------------------------------------------------------------------------------------------------------------------------------------------

第6章 课程总结
课程重点总结
 6-1 6 课程总结 (05:11)


-------------------------------------------------------------------------------------------------------------------------------------------


快速入门ThinkPHP 5.0 --模型篇

第1章 课程介绍
本章节对全篇所学内容进行梳理，通览全部知识点
最近学习
 1-1 教程简介 (03:01)
第2章 Thinkphp 5.0 对数据库的操作
本章节讲解了如何使用Thinkphp 5.0 对数据库实现增删改查操作，并讲解了thinkphp 5.0 的条件构造器~
 2-1 数据库的连接操作 (10:45)
 2-2 数据库查询操作 (18:42)
 2-3 添加数据 (08:54)
 2-4 数据库更新操作 (10:29)
 2-5 数据库删除操作 (03:49)
 2-6 条件构造器 (12:06)
 2-7 链式操作 (10:40)
第3章 Thinkphp 5.0 的模型
本章节详细讲解了thinkphp5.0的模型，已经使用模型对数据进行增、删、改、查操作
 3-1 什么是模型 (09:16)
 3-2 使用模型查询数据 (11:38)
 3-3 使用模型添加数据 (13:52)
 3-4 使用模型更新数据 (13:14)
 3-5 使用模型删除数据 (05:09)
 3-6 模型聚合操作 (07:56)
 3-7 模型获取器 (06:21)
 3-8 模型修改器-+自动完成 (11:51)
 3-9 模型时间戳+软删除 (18:53)
第4章 课程总结
本章节第本门课程的重点、难点知识进行回顾
 4-1 课程总结 (02:21)

-------------------------------------------------------------------------------------------------------------------------------------------


快速入门ThinkPHP 5.0 --模型篇

第1章 课程介绍
本章节对全篇所学内容进行梳理，通览全部知识点
最近学习
 1-1 教程简介 (03:01)

      ThinkPHP5 数据模型

      课程大纲： 

               1、数据库操作

               2、ThinkPHP 模型



  在学习开始之前，可以先将入口文件修改以下内容，与作者保持一致，方便学习和理解

    // [ 应用入口文件 ]

         // 定义应用目录

                 define('APP_PATH', __DIR__ . '/../app/');  //在这里，将“application” 修改为 “app”, 
                                                                 再将application文件夹名称修改为app文件夹名称，方便理解命名空间

         //自定义配置文件目录：自创的  ,与app目录同级

                 define('CONF_PATH', __DIR__. '/../conf/');




-------------------------------------------------------------------------------------------------------------------------------------------

第2章 Thinkphp 5.0 对数据库的操作

     本章节讲解了如何使用Thinkphp 5.0 对数据库实现增删改查操作，并讲解了thinkphp 5.0 的条件构造器~

     2-1 数据库的连接操作 (10:45)

      1、设置应用配置 conf目录下的 数据库配置 database.php 内容：


                <?php

                  return [
                  
                           // 数据库类型
                        'type'            => 'mysql',
                        // 数据库连接DSN配置
                        'dsn'             => '',
                        // 服务器地址
                        'hostname'        => '127.0.0.1', //本机：127.0.0.1
                        // 数据库名
                        'database'        => 'imooc_course',
                        // 数据库用户名
                        'username'        => 'root',
                        // 数据库密码
                        'password'        => '123456',
                        // 数据库连接端口
                        'hostport'        => '3306',
                        // 数据库连接参数
                        'params'          => [],
                        // 数据库编码默认采用utf8
                        'charset'         => 'utf8',
                        // 数据库表前缀
                        'prefix'          => '',     //同一个数据库中：数据库表前缀，我们可以通过它来给我们的表添加前缀
                        // 数据库调试模式
                        'debug'           => false,
                        // 数据库部署方式:0 集中式(单一服务器),1 分布式(主从服务器)
                        'deploy'          => 0,
                        // 数据库读写是否分离 主从式有效
                        'rw_separate'     => false,
                        // 读写分离后 主服务器数量
                        'master_num'      => 1,
                        // 指定从服务器序号
                        'slave_no'        => '',
                        // 是否严格检查字段是否存在
                        'fields_strict'   => true,
                        // 数据集返回类型
                        'resultset_type'  => 'array',
                        // 自动写入时间戳字段
                        'auto_timestamp'  => false,
                        // 时间字段取出后的默认时间格式
                        'datetime_format' => 'Y-m-d H:i:s',
                        // 是否需要进行SQL性能分析
                        'sql_explain'     => false,
                        // Builder类
                        'builder'         => '',
                        // Query类
                        'query'           => '\\think\\db\\Query',

                  ]


                ?>


      2、连接数据库
 
          （1）、连接数据库的第1种方法：数据库的配置放在应用配置conf/database.php中

                    namespace app\index\controller;
                      use think\View;
                      use think\Controller;
                      use think\Db;
                      class Index extends Controller{

                           public function index(){
                                
                             // dump(config('database'));

                             //连接数据库的第1种方法：

                             $res = Db::connect();  

                             //进行数据库连接 , 当我们只使用这段代码的时候，其实并没有真正的连接数据库，只有我们进行增删改查的时候，才是真正的连接。
                             //dump($res);
                           }  
                      } 



          （2）、连接数据库的第2种方法： 数据库的配置直接放在connect函数中。

                    namespace app\index\controller;
                      use think\View;
                      use think\Controller;
                      use think\Db;
                      class Index extends Controller{

                           public function index(){
                                
                             //连接数据库的第2种方法： 数据库的配置直接放在connect函数中。
                               $res = Db::connect(
                               [
                                   // 数据库类型
                                'type'            => 'mysql',
                                // 数据库连接DSN配置
                                'dsn'             => '',
                                // 服务器地址
                                'hostname'        => '127.0.0.1', //本机：127.0.0.1
                                // 数据库名
                                'database'        => 'imooc_course',
                                // 数据库用户名
                                'username'        => 'root',
                                // 数据库密码
                                'password'        => '123456',
                                // 数据库连接端口
                                'hostport'        => '3306',
                                // 数据库连接参数
                                'params'          => [],
                                // 数据库编码默认采用utf8
                                'charset'         => 'utf8',
                                // 数据库表前缀
                                'prefix'          => '',     //同一个数据库中：数据库表前缀，我们可以通过它来给我们的表添加前缀
                                // 数据库调试模式
                                'debug'           => false,
                                // 数据库部署方式:0 集中式(单一服务器),1 分布式(主从服务器)
                                'deploy'          => 0,
                                // 数据库读写是否分离 主从式有效
                                'rw_separate'     => false,
                                // 读写分离后 主服务器数量
                                'master_num'      => 1,
                                // 指定从服务器序号
                                'slave_no'        => '',
                                // 是否严格检查字段是否存在
                                'fields_strict'   => true,
                                // 数据集返回类型
                                'resultset_type'  => 'array',
                                // 自动写入时间戳字段
                                'auto_timestamp'  => false,
                                // 时间字段取出后的默认时间格式
                                'datetime_format' => 'Y-m-d H:i:s',
                                // 是否需要进行SQL性能分析
                                'sql_explain'     => false,
                                // Builder类
                                'builder'         => '',
                                // Query类
                                'query'           => '\\think\\db\\Query',

                          ]);
                               dump($res);
                           }
                      } 
                    ?>



          （3）、连接数据库的第3种方法： connect函数中接受一个dsn格式的字符串。

                  dsn格式的字符串： "mysql://root:possword@127.0.0.1:3306/imooc_course3#utf8"

                  namespace app\index\controller;
                      use think\View;
                      use think\Controller;
                      use think\Db;
                      class Index extends Controller{

                           public function index(){
                               
                              $res = Db::connect("mysql://root:possword@127.0.0.1:3306/imooc_course3#utf8"); 

                              //进行数据库连接 , 当我们只使用这段代码的时候，其实并没有真正的连接数据库，只有我们进行增删改查的时候，才是真正的连接。
                             //dump($res);
                           }  
                      } 



          （4）、连接数据库的第4种方法： connect函数中接受一个在应用配置config.php配置好的参数"db_config01"。

                  db_config01在config.php中的配置如下：

                   'db_config01' => [
                      
                         // 数据库类型
                      'type'            => 'mysql',
                      // 数据库连接DSN配置
                      'dsn'             => '',
                      // 服务器地址
                      'hostname'        => '127.0.0.1', //本机：127.0.0.1
                      // 数据库名
                      'database'        => 'imooc_course4',
                      // 数据库用户名
                      'username'        => 'root',
                      // 数据库密码
                      'password'        => '123456',
                      // 数据库连接端口
                      'hostport'        => '3306',
                      // 数据库连接参数
                      'params'          => [],
                      // 数据库编码默认采用utf8
                      'charset'         => 'utf8',
                      // 数据库表前缀
                      'prefix'          => '',     //同一个数据库中：数据库表前缀，我们可以通过它来给我们的表添加前缀
                   ],



               index.php文件：

                  namespace app\index\controller;
                      use think\View;
                      use think\Controller;
                      use think\Db;
                      use think\Config;
                      class Index extends Controller{

                           public function index(){
                               
                              $res = Db::connect("db_config01"); 

                             //dump($res);
                           }  
                      } 


                    解析：

                         这里的  Db::connect("db_config01")

                            相当于  Db::connect(Config::get('db_config01')) ;

                         这里是因为Db类为我们提供了不需要使用 Config::get 的配置






-------------------------------------------------------------------------------------------------------------------------------------------

 2-2 数据库查询操作 (18:42)

      数据库名： imooc_course
      默认字符集: utf8     
      默认排序规则： utf8_general_ci


         1、注意 : 数据库建字段，默认值空和empty string有什么区别？

               null=空；empty string=空字符串。可以了解为零字节长度的字符串。另外，要注意一点，就是sql查询的时候要是空的字符串会查询出为空，要是null的话，会提示sql语句有错。那这样的话，好像是数据库校对字符集的问题。


         2、查询数据库imooc_course中的imooc_user表
   
              首先我们要在数据库中创建 imooc_course数据库和imooc_user

              sql内容：

                   use imooc_course;

                   
create table imooc_user(

    

                              id int not null auto_increment primary key,

                              username varchar(60) not null,
     
                              password char(32) not null,
	 
                              email varchar(100) not null
);

                   select *from imooc_user;

                   
SELECT * FROM imooc_course.imooc_user;


                   insert into imooc_course.imooc_user values (1,"imooc_arvin",'123456','1095654362@qq.com');

                   
insert into imooc_user values (2,"imooc_arvin",'123456','1095654362@qq.com');




                 #########################################################

            （1） #使用sql语句的方式查询数据库:使用query查询数据库

                  namespace app\index\controller;
                      use think\View;
                      use think\Controller;
                      use think\Db;
                      class Index extends Controller{

                           public function index(){
                                
                           //$res = Db::connect();  //进行数据库连接 , 当我们只使用这段代码的时候，其实并没有真正的连接数据库，只有我们进行增删改查的时候，才是真正的连接。

                          #使用sql语句的方式查询数据库

                           $res = Db::query("select * from imooc_user where id=?", [1]);
                           // $res = Db::query("select * from imooc_user");
                           dump($res);

                           }                          
                      }      


            （2） #使用 execute 执行sql语句

                            $res = Db::execute("insert into imooc_user set username=?, password=?,email=?",[
                               'imooc',
                               md5('imooc'),
                               'imooc@qq.com'
                            ]);
                           dump($res);

                    页面打印显示：  D:\wamp\www\think_web\thinkphp\library\think\Debug.php:165: int 1

                    解析： ‘int 1’： 表示当前有一条记录被影响


             （3） #select 返回所有记录，返回的结果是一个二维数组  如果结果不存在，返回一个空数组。

                   ①查询整张表的数据：

                           $res = Db::table('imooc_user')->select();
                           dump($res);

                    页面打印显示：
  
                      D:\wamp\www\think_web\thinkphp\library\think\Debug.php:165:
                      array (size=3)
                        0 => 
                          array (size=4)
                            'id' => int 0
                            'username' => string 'imooc' (length=5)
                            'password' => string '914f21eb84c6fdb2b663dd6f453f65ca' (length=32)
                            'email' => string 'imooc@qq.com' (length=12)
                        1 => 
                          array (size=4)
                            'id' => int 1
                            'username' => string 'imooc_arvin' (length=11)
                            'password' => string '123456' (length=6)
                            'email' => string '1095654362@qq.com' (length=17)
                        2 => 
                          array (size=4)
                            'id' => int 2
                            'username' => string 'imooc_arvin' (length=11)
                            'password' => string '123456' (length=6)
                            'email' => string '1095654362@qq.com' (length=17)



                   ②添加where条件查询表的数据：

                           $res = Db::table('imooc_user')->where([

                                   'id'=> '100'

                               ])->select();

                           dump($res);

                       页面打印显示：array (size=0)

                       解析： 因为数据库里面没 id=100 的数据，如果结果不存在，返回一个空数组。

            
             （4） 使用find（）方法

                     $res = Db::table('imooc_user')->find();
                     dump($res);

                     页面打印显示：

                               array (size=4)
                                 'id' => int 0
                                 'username' => string 'imooc' (length=5)
                                 'password' => string '914f21eb84c6fdb2b663dd6f453f65ca' (length=32)
                                 'email' => string 'imooc@qq.com' (length=12)

                     解析： 使用find（）方法时，会默认返回一条记录，而不会返回整张表的记录。

                            返回的结果是一个一维数组

                            如果结果不存在，返回 NULL


             （5） 使用value（）方法

                      value 返回一条记录，而不会返回整张表的记录,并且是字段记录的某个字段值
   
                      如果结果不存在， 返回null

                           $res = Db::table('imooc_user')->value('username');
                           $res = Db::table('imooc_user')->where(['id' => '100'])->value('username');
                           dump($res);


             （6） 使用column（）方法

                            #column 返回一个一维数组，即返回整张表某个字段的一整列记录字段值,数组中的value值就是我们要获取的列的值
                            #如果结果不存在， 返回null

                   ①只返回一个字段的字段值数据：                    

                              $res = Db::table('imooc_user')->column('username');
                              dump($res);

                       页面返回：
                                 array (size=3)
                                   0 => string 'imooc' (length=5)
                                   1 => string 'imooc_arvin' (length=11)
                                   2 => string 'imooc_arvin' (length=11)

                       解析：#column 返回一个一维数组，即返回整张表某个字段的一整列记录字段值,数组中的value值就是我们要获取的列的值

                   ②只返回多个字段的字段值数据：column(）存在第二个参数 

                            $res = Db::table('imooc_user')->column('email','username'); 
                            // $res = Db::table('imooc_user')->where(['id' => '10'])->column('email','username');                       
                            dump($res);

                       页面返回：
                                 array (size=2)
                                   'imooc' => string 'imooc@qq.com' (length=12)
                                   'imooc_arvin' => string '109@qq.com' (length=10)


                       解析： 如果存在第二个参数，就返回这个数组并且用第二个参数的值作为数组的key值

                              如果存在第二个参数，且结果不存在，则返回一个空数组

              总结Db::table()：

                1、Db::table() 中 有 4 种方法

                          ①、Db::table('imooc_user')->select();
          
                          ②、Db::table('imooc_user')->find();
 
                          ③、Db::table('imooc_user')->value('username');

                          ④、Db::table('imooc_user')->column('username');

                2、Db::table() 中 有 4 种方法的区别：

                        select（）和 column（）返回的是返回一个数组，且结果不存在时，返回一个空数组。

                        find（）和 value（）只返回一条记录，且如果结果不存在， 返回null


             （7）Db::name('user') 的使用

                     #使用Db::name, 我们就不用写数据路表前缀‘imooc_user’,直接写‘user’即可

                     $res = Db::name('user')->select();

                     dump($res);

                     返回结果与 $res = Db::table('imooc_user')->select();  一样

                     这里之所以可以省略前缀， 是因为我们在 应用配置conf目录的数据库配置database.php 中

                     配置了 
                           // 数据库表前缀        
                              'prefix' => 'imooc_',  

                     在我们的实际开发过程中一般会设置表前缀，所以我们一般会使用 Db::name() 多于 使用 Db::table（）。


             （8）另外在thinkphp中，它还为我们提供了一个初始函数 db() ,   也可以忽略不写表前缀

                           $res = db('user')->select();
 
                           $res = db('user')->find();

                           dump($res);                        


                     返回结果和我们使用 Db::table（）是一样的

                  
                   注意：
 
                       Db::table() 和 db() 的区别？

                         Db::table() 每次使用的时候不是去实例化， 而db()每次使用的时候都需要去实例化。

                         如果我们不想让 db()重新实例化的时候，我们需要给db()传递第三个参数，如下：

                          $res = db('user',[],false)-find();   
                          dump($res);




-------------------------------------------------------------------------------------------------------------------------------------------


 2-3 添加数据 (08:54)

           在这里演示的时候，我们先将数据库表设置成 MyISAM 类型，方便演示，

           但是在实际开发过程中，我们还是设置 数据库表为 InnoDB 类型

           1、insert（）：返回值是影响记录的行数， 在这里为插入数

                             $db = Db::name('user');  //这样写，就不用每次都写Db::name('user')

                             #insert
                             $res = $db->insert([
                                'email' => 'imooc_02@qq.com',
                                'password' => md5('imooc_02'),
                                'username' => 'imooc_02'
                             ]);
                             dump($res);

             每刷新一次页面，运行以上一次=代码，都会给数据库添加一条新的数据。

             注意：当我们给 主键id 设置自增的时候，我们就不能给它设置默认值，不然当我们在用 insert 插入数据时，不给id设置值时，会报错

             
           2、insertGetId（）： 这个方法的优点是 它最后返回值 是 自增id 的值

                             $res = $db->insertGetId([
                                'email' => 'imooc_02@qq.com',
                                'password' => md5('imooc_02'),
                                'username' => 'imooc_02'
                             ]);

                             dump($res);

                页面打印显示： D:\wamp\www\think_web\thinkphp\library\think\Debug.php:165:string '4' (length=1)

                解析：  string'4' 说明我们最后的 自增id 的值为 4


          3、insertAll 插入多条数据 ： 返回值是 插入数据成功的行数

                             $data = [];  // 首先我们定义一个数组$data，并且用 for循环向数组$data插入多条数据 
                             for($i=0; $i<10; $i++){

                                $data[] = [
                                'email' => "imooc__03_{$i}@qq.com",
                                'password' => md5("imooc_03_{$i}"),
                                'username' => "imooc_03_{$i}"
                               ];
                             }

                             $res = db::insertAll($data); // 使用 insetAll（）将 $data 的所有数据插入到数据库中。
                             dump($res);             

                             insertAll返回值是 插入数据成功的行数 ，即我们可以利用这个返回值 去判断是否等于 数组$data 的长度，即可判断出是否所有的数据都插入成功。




-------------------------------------------------------------------------------------------------------------------------------------------



 
 2-4 数据库更新操作 (10:29)

                             // $data = [];  //首先先将之前表数据都清除，并且新增30条新数据，方便进行演示，添加成功后，将以下代码进行注释，防止重复添加数据
                             // for($i=0; $i<30; $i++){
                             //    $data[] = [
                             //    'email' => "imooc__03_{$i}@qq.com",
                             //    'password' => md5("imooc_03_{$i}"),
                             //    'username' => "imooc_03_{$i}"
                             //   ];
                             // }



     1、update :返回影响的行数

                         #注意： 在使用update时，我们必须使用 where（）添加 更新条件，不然会报错，

                         # 如果我们在更新所有数据，我们可以 传一个恒等条件 '1=1'

                             $db = Db::name('user');  //这样写，就不用每次都写Db::name('user')

                             $res = $db -> where([

                                'id' => 2

                             ])->update([

                               "username" => 'aben',
                               'email' => 'aben@qq.com'
                             ]);

                             dump($res);  


     2、setField: 返回影响数据的行数,每次只更新一个字段

                              $res = $db -> where([

                                 'id' => 3

                              ])->setField([

                                 "username" => 'aben',
                              ]);


     3、setInc:  给数据库表所条件选择出来的记录的某个字段实现自增  ，返回影响数据的行数

                             $res = $db -> where([
                                'id' => 1
                             ])->setInc('num');   
                         
                             dump($res);   

          解析： 以上代码给表imooc_user 所条件选择出来的记录 的 num 字段实现自增，每执行一次代码，num的值会增加1，

                 注意：经过测试，发现num里得先有数字，即使是0也行，只要有数字才成功


                             $res = $db -> where([
                                'id' => 1
                             ])->setInc('num',5);                            
                              dump($res);  

 
           解析： 但setInc（）有第二个参数存在时，例如 setInc('num',5)， 表示以上代码给表imooc_user 所条件选择出来的记录 的 num 字段实现自增，每执行一次代码，num的值会增加5，




     4、setDec:  给数据库表所条件选择出来的记录的某个字段实现自减  ，返回影响数据的行数

                             $res = $db -> where([
                                'id' => 1
                             ])->setDec('num');                            
                              dump($res);   

          解析： 以上代码给表imooc_user 所条件选择出来的记录 的 num 字段实现自减，每执行一次代码，num的值会减1，


                             $res = $db -> where([
                                'id' => 1
                             ])->setDec('num',5);                            
                              dump($res);  

                解析： 但setDec（）有第二个参数存在时，例如 setDec('num',5)， 表示以上代码给表imooc_user 所条件选择出来的记录 的 num 字段实现自减，每执行一次代码，num的值会减 5。

                      注意： 但我们的字段，如 num 字段设置为无符号时，当setDec('num',5)自减至负数时，会报错，因为当前字段不允许为负数


        总结：

                 SQL:update 返回影响的行数

                          $db=DB:name('user');

                          $db->where([])->update([一维数组]);


                 SQL：setField 返回影响数据的行数，每次只更新一个字段

                          $db->where([])->setField ('字段名'，'值');

                          $db->where([])->setInc($fieldname,$num);增加，不设置第二个参数默认为一

                          $db->where([])->setDec($fieldname,$num);减少





-------------------------------------------------------------------------------------------------------------------------------------------


 2-5 数据库删除操作 (03:49)

      1、 #delete  : 返回值为被影响数据的行数

                               $db = Db::name('user');  //这样写，就不用每次都写Db::name('user')

                               $res = $db->where([

                                   'id' => 1

                               ])->delete();
   


      2、如果我们想删除主键的数据，我们可以省略where（），如下删除 主键id 为2 的数据

                              $res = $db->delete(2);



      3、若我们直接写"$res = $db->delete()",是会报错的，在我们的程序中，我们一般不会删除所有数据的

         若我们想要删除所有数据，可以写恒等条件 "1=1",如下：

                              $res = $db->where('1=1')->delete();




  额外笔记：

        1、 sql语句 删除表数据drop、truncate和delete的用法：

         （1）老大------drop

                 出没场合:drop table  tb --tb表示数据表的名字,下同

                 绝招:删除内容和定义，释放空间。简单来说就是把整个表去掉.以后要新增数据是不可能的,除非新增一个表,

                 例如:一个班就是一个表,学生就是表中的数据,学生的职务就是定义

                            drop table class,就是把整个班移除.学生和职务都消失


         （2）老二-----truncate（截断）

                出没场合:truncate table tb

                绝招:删除内容、释放空间但不删除定义。与drop不同的是,他只是清空表数据而已,他比较温柔.

                同样也是一个班,他只去除所有的学生.班还在,职务还在,如果有新增的学生可以进去,也可以分配上职务

                删除内容很容易理解,不删除定义也很容易理解,就是保留表的数据结构

               截断表的执行速度与不带where子句的delete（删除）命令相同，甚至比它还要快。delete（删除）一次删除一行数据，并且将每一行被删除的数据都作为一个事务记录日志；而truncate （截断）表则回收整个数据页，只记录很少的日志项。delete（删除）和truncate（截断）都会回收被数据占用的空间，以及相关的索引。只有表的拥有者可以截断表。

               另外，truncate表之后，如果有自动主键的话，会恢复成默认值。


         （3）老三-----delete

                 出没场合:delete table tb   --虽然也是删除整个表的数据,但是过程是痛苦的(系统一行一行地删,效率较truncate低)

                            或

                           delete table tb where 条件

                 绝招:删除内容不删除定义，不释放空间。三兄弟之中最容易欺负的一个



        2、TP5报错页面：报错界面要出现详细错误的提示，要怎么设置呢？我按照默认的不会给出详细错误提示

            在应用配置文件中，conf.php配置：

                 配置文件里把debug 设置成true就会提示详细的错误提示了。





-------------------------------------------------------------------------------------------------------------------------------------------


 2-6 条件构造器 (12:06)

     # buildSql(): 返回 sql语句

       $db = Db::name('user');  //这样写，就不用每次都写Db::name('user')

    1、
                 //筛选条件： id=1 的情况

                       //where(['id=>1'])等同于where('id',1)等同于where('id=1');

                       $sql = $db->where(['id'=>1])-> buildSql(); //返回：string '( SELECT * FROM `imooc_user` WHERE  `id` = 1 )'

                       $sql = $db->where("id=1")-> buildSql();  //返回:string '( SELECT * FROM `imooc_user` WHERE  (  id=1 ) )'

                       $sql = $db->where("id",1)-> buildSql();  //返回:string '( SELECT * FROM `imooc_user` WHERE  `id` = 1 )'


                 //筛选条件： id 不等于 1 的情况

                       //where("id","<>",1)等同于where("id","NEQ",1)

                       //$sql = $db->where("id","<>",1)-> buildSql(); //返回: string '( SELECT * FROM `imooc_user` WHERE  `id` <> 1 )'
                       //$sql = $db->where("id","NEQ",1)-> buildSql(); //返回: string '( SELECT * FROM `imooc_user` WHERE  `id` <> 1 )'


                 //筛选条件： id 大于等于 1 的情况

                       //where("id","EGT",1)等同于where("id",">=",1)

                       //$sql = $db->where("id","EGT",1)-> buildSql(); //string '( SELECT * FROM `imooc_user` WHERE  `id` >= 1 )'


                 //(NOT)BETWEEN， 当使用BETWEEN时，第三个参数需要是一个字符串

                       //$sql = $db->where("id","BETWEEN","1,5")-> buildSql();// string '( SELECT * FROM `imooc_user` WHERE  `id` BETWEEN 1 AND 5 )' 1 )'

                       //$sql = $db->where("id","NOTBETWEEN","1,5")-> buildSql();// '( SELECT * FROM `imooc_user` WHERE  `id` NOT BETWEEN 1 AND 5 )'

                       //注意： 这里当我们在第三个参数中多写一个20时，20 是无效的，系统是会自动忽略这个20的
                       //$sql = $db->where("id","NOTBETWEEN","1,5,20")-> buildSql(); // '( SELECT * FROM `imooc_user` WHERE  `id` NOT BETWEEN 1 AND 5 )'


                 //IN
                       //where("id","IN","1,5,20")等同于where("id","IN",[1,5,20])


                       //$sql = $db->where("id","IN","1,5,20")-> buildSql(); // string '( SELECT * FROM `imooc_user` WHERE  `id` IN (1,5,20) )'


           2、//where中另一种表达方法：使用数组

              （1）  //筛选条件： id 大于等于 1 的情况

                     //string '( SELECT * FROM `imooc_user` WHERE  `id` >= 1 )

                     // $sql = $db->where([
                          
                     //"id" => ["EGT",1]

                     // ])-> buildSql();


               （2） //筛选条件： id in (1,2,3,4,5)

                     //string '( SELECT * FROM `imooc_user` WHERE  `id` IN (1,2,3,4,5) )'

                     // $sql = $db->where([
                            
                     //     "id" => ["IN",[1,2,3,4,5]]

                     // ])-> buildSql();


                （3） //筛选条件： id in (1,2,3,4,5)  and username = "arvin"

                        //string '( SELECT * FROM `imooc_user` WHERE  `id` IN (1,2,3,4,5)  AND `username` = 'arvin' )'

                        $sql = $db->where([
                          
                           "id" => ["IN",[1,2,3,4,5]],

                           "username" => "arvin"
  
                          ])-> buildSql();



                （4）使用 EXP ： 表达式查询,支持SQL语法     EXP，类似于拼接的作用，在代码编译的时候把前后拼接起来

                       //$sql = $db->where("id","EXP","not in (1,2,3)")-> buildSql();//输出的sql语句： string '( SELECT * FROM `imooc_user` WHERE  ( `id` not in (1,2,3) ) )' 

                        //$sql = $db->where("id","in","1,2,3")-> buildSql(); //输出的sql语句：string '( SELECT * FROM `imooc_user` WHERE  `id` IN (1,2,3) )'


                （5）添加多个条件连续使用where: AND 条件

                           // $sql = $db
                           //          ->where("id","in","1,2,3")
                           //          ->where("username","eq","arvin")
                           //          -> buildSql(); 

                           // string '( SELECT * FROM `imooc_user` WHERE  `id` IN (1,2,3)  AND `username` = 'arvin' )'


                （6）添加多个条件，使用whereOr: or 条件

                           // $sql = $db
                           //          ->where("id","in","1,2,3")
                           //          ->whereOr("username","eq","arvin")
                           //          -> buildSql(); 

                           // '( SELECT * FROM `imooc_user` WHERE  `id` IN (1,2,3) OR `username` = 'arvin' )'



                （7）添加多个条件，使用多个whereOr: or 条件

                           $sql = $db
                                    ->where("id","in","1,2,3")
                                    ->whereOr("username","eq","arvin")
                                    ->whereOr("num","lt","10")
                                    -> buildSql(); 
                                    
                          // '( SELECT * FROM `imooc_user` WHERE  `id` IN (1,2,3) OR `username` = 'arvin'  OR `num` < 10 )' 



                （8）添加多个条件，同时使用多个whereOr和where: and 条件 和 or 条件

                           $sql = $db
                                    ->where("id","in","1,2,3")
                                    ->whereOr("username","eq","arvin")
                                    ->whereOr("num","lt","10")
                                    ->where("email","eq","109@qq.com")
                                    -> buildSql(); 

                         // string '( SELECT * FROM `imooc_user` WHERE  `id` IN (1,2,3)  AND `email` = '109@qq.com' OR `username` = 'arvin'  OR `num` < 10 )' 





  总结笔记：

         1、
              注意： 表达式都是不分大小写的

                        buildSql();返回SQL语句

                        where('字段名','表达式','查询条件');

                        表达式     含义

                        EQ、=        等于（=） 

                        NEQ、<>      不等于（<>） 

                        GT、>        大于（>） 

                        EGT、>=      大于等于（>=） 

                        LT、<                    小于（<） 

                        ELT、<=                  小于等于（<=） 

                        LIKE                        模糊查询 

                        [NOT] BETWEEN   (不在)区间查询 

                        [NOT] IN                (不在)IN 查询( 'id','in' ,'1,5,8'( [1,5,8] ) )

                        [NOT] NULL  查询字段是否（不）是NULL 

                        [NOT] EXISTS    EXISTS查询 

                        EXP         表达式查询,支持SQL语法     EXP，类似于拼接的作用，在代码编译的时候把前后拼接起来

                        > time      时间比较 

                        < time      时间比较 

                        between time    时间比较 

                        notbetween time     时间比较 

                        <!-- Db::table  -->

                        Db::table('据库名')->where()->buildSql();

                        <!-- Db::name 方法同上 -->

                        Db::name('不戴前置数据库名')->where()->buildSql();


         2、数组的方式可以给   值的数组的第一个参数设置条件结构 where(['id' => ['LT',5]])等同于where('id<5')



         3、使用的时候，建议使用这种方式where('username','eq', 'wenco_1')

                   如果是多个and关系可以使用数组或者多个where方法

                              ->where('id','exp' ,'not in(1,2,3)') 
               
                              ->whereOr('username','eq', 'wenco_1')来构造我们的where条件







-------------------------------------------------------------------------------------------------------------------------------------------




 2-7 链式操作 (10:40)


        首先截断(truncate)掉 imooc_user 表的所有数据，再为 imooc_user 添加新的数据

                           $db = Db::name('user');  //这样写，就不用每次都写Db::name('user')

                           $data = [];
                           for($i=1; $i<21; $i++){

                               $data[]  = [
                                    "username" => "imooc_arivn_{$i}",
                                    "email" => "imooc_arivn_{$i}@qq.com",
                                    "password" => md5("imooc_{$i}"),
                                    "num" => $i+100
                               ];
                           }
 
                           $res =  $db-> insertAll($data);

                      执行完代码后，将代码注释掉，我们只需要添加一次数据

       1、
           #演示:  常见的链式方法： where、field、order、limit、page、select


                           $res = Db::table("imooc_user")

                              // ->where("id",">","10")  //添加筛选条件

                                 ->field("username,id,group")  //只查看"username" 和 "id" 字段

                              // ->order("id DESC")      // 根据某个字段进行排序，这里表根据id字段进行降序，默认升序

                              // ->limit(3)            // '3' 表示返回前3条记录

                              // ->limit(3,5)            // (3,5) 表示从第三条吉记录开始取数据，取5条数据

                              // ->page(2,5)             // 分页取数据， page(x) 相当于 limit((x-1)*5,5) 。 (2,5)表示取第二页的前5条数据

                               ->group("`group`")      // group表示分组，注意：但我们的字段名为'group'这种关键字时，我们需要添加反引号``符号，将其转为字符串，不然会报错。这个表示按照‘group’字段来进行分组，并且返回每组的第一个记录。

                               ->select();             // 返回筛选条件后的数据库表数据



       2、注意：

            （1）、group() 和 order() 同时调用时，先分组后排序。

                   order对group是不起作用的;就是在执行的group进行分组的时候，并不是在你order排序的基础上进行的;


       3、额外笔记

常用链式操作   

原理:Db类的链式方法返回Db对象,可以继续使用Db对象的这些方法对查询数据进行一些条件构造以及范围的选择和排序等等;
 

$res=$db

	->where('id','>',5)		条件ID>5

	->field('username','id')	只搜索username和id两个字段

	->order('id DESC')		order排序	id DESC   id倒序

	->limit(3,7)		limit截取  3,7   从3开始截取7个

	->page(3,5)		page(m,n)多用于分页//limit分页limit((m-1)*n,n)== m:当前页数，n:每页多少条数据

	->group('`group`')	//group是关键字，这里用``进行转义	

	->select();			select(	);  搜索

	var_dump($res);



注意：order对group是不起作用的;就是在执行的group进行分组的时候，并不是在你order排序的基础上进行的;

group('字段')，他会根据字段的值为分类标准进行分类，比如字段值为1的单独查出来，字段值为1的单独查出来;


-------------------------------------------------------------------------------------------------------------------------------------------




第3章 Thinkphp 5.0 的模型

 本章节详细讲解了thinkphp5.0的模型，已经使用模型对数据进行增、删、改、查操作

 3-1 什么是模型 (09:16)

         为什么要使用模型？

            虽说在控制器里也可以完成对数据库的各种操作，但是不利于其他控制器重用；把这些对数据库的重复操作封装到model，可以提高代码的重用性；多个控制器调用同一个model类即可


        1、首先我们的模型需要写在应用下的model目录。

             如：
                 我们想写 index 模块的模型时，我们需要在 index模块中创建一个model目录（这样子就和我们之前所有的controller控制器和view视图一起构成了MVC模式）

             我们在 index\model中创建一个 User.php

             注意： model模型中的文件（即类名）的命名方式： 采用驼峰，并且是根据数据表名来命名的。

                         如果数据库表名为 imooc_user，则对应的模型文件名为 User.php   类名为 User

                         如果数据库表名为 imooc_user_info ，则对应的模型文件名为 UserInfo.php   类名为 UserInfo

                     即命名方式为 去除数据库表名的前缀，即为我们需要设置的模型文件名和类名。           

              当我们命名为  模型文件名为 UserInfo.php   类名为 UserInfo  ，系统会自动对应要 数据库表 imooc_user_info



        2、如何定义创建model模型, 并且在模块的控制器中使用model

        例子:

         （1）如何定义创建 model ： User model模型

                在app\index\model目录下创建 User.php

               app\index\model\User.php 内容： 

					<?php

					 namespace app\index\model;

					 use think\Model;

					 class User extends Model{

					     # 命名 imooc_user -> User.php User
					 	 #  imooc_user_info -> UserInfo.php UserInfo					 	

					 }
					?>

                        解析： 这里的 User类 仅仅只是继承了 Model类， 没有其他内容，不过即可以使用 Model类的方法


         （2）在index模块的控制器中使用 index 模型 的几种方法：

            namespace app\index\controller;

            use think\Controller;
            //use app\index\model\User;
            use think\Loader;
            class Index{

                  public  function index(){
         
                       #使用model模型获取数据的方法：
 

                         #①、使用静态方法
                      // $res = User::get(1);  //这里 静态方法 get(1)表示返回 User模型对应的数据库表imooc_user 的id字段为1数据
                                               //User的get（）是从model类继承下来的



                         #②、实例化对象,使用对象的get()方法
                       //   $user = new User;
                       //   $res = $user::get(3);  表示返回 User模型对应的数据库表imooc_user 的id字段为3数据



                         #③、我们可以先注释掉“use app\index\model\User;”，添加“use think\Loader;”
                            //然后通过loader方法来获取我们的model
                            //如果我们在同一个模块中使用多个模型，就可以使用这种方法，就不用每次都需要添加类似“use app\index\model\User;”的语句
                            //$user = Loader::model("User");
                            //$res = $user::get(4);  // 表示返回 User模型对应的数据库表imooc_user 的id字段为4数据



                         #④、使用model的初始函数  
                            //优点:这个方法不需要我们引入任何的类。即我们可以删除掉 “use app\index\model\User;” 和 “use think\Loader;” 代码
                            $user = model("User");
                            $res = $user::get(6);  //表示返回 User模型对应的数据库表imooc_user 的id字段为6数据



                       //建议一般使用前两种方式，最好使用前两种方式，因为初始函数是可能会被我们覆盖掉的（虽然很少发生）
                            //为了代码可读性更高，建议使用第一种方式：引入相关类，再使用其静态方法。 这样代码看起来会更清晰，后期维护方便。

                       $res = $res->toArray();
                       dump($res);
                             
                  }

            }           


                 注意：
                       建议一般使用前两种方式，最好使用前两种方式，因为初始函数是可能会被我们覆盖掉的（虽然很少发生）

                       为了代码可读性更高，建议使用第一种方式：引入相关类，再使用其静态方法。 这样代码看起来会更清晰，后期维护方便。





-------------------------------------------------------------------------------------------------------------------------------------------


 3-2 使用模型查询数据 (11:38)

        在app\index\model目录下创建 User.php

        这里的 User类 仅仅只是继承了 Model类， 没有其他内容，不过即可以使用 Model类的方法

               app\index\model\User.php 内容： 

					<?php

					 namespace app\index\model;

					 use think\Model;

					 class User extends Model{

					     # 命名 imooc_user -> User.php User
					 	 #  imooc_user_info -> UserInfo.php UserInfo					 	

					 }
					?>


   ##########################################################


                      $res = User::get(1);
                      dump($res);    //这里直接打印的是一个对象 ，数据可能会比较多且乱，可以先使用toArray()方法


                      $res = User::get(1);
                      $res = $res->toArray();  
                      dump($res);   //获取筛选的所有数据，以数组的形式打印




       1、演示：   #查询的几种方法：


            namespace app\index\controller;

            use think\Controller;
            use app\index\model\User;
            use think\Db;
            class Index{

                  public  function index(){   

                    #查询的几种方法：


                      #（1）、get()函数中传递所要查询的表的主键id值为1的记录。

                      //$res = User::get(1);
                      //dumo($res->username); //获取筛选后某个字段的数据
                      //dump($res); 


                      
                      #（2）、get()函数中传递函数 :  获取 字段‘username’的值是 ‘imooc_arvin_4’ 的记录 

                      // $res = User::get(function($query){
                      //     $query->where("username","eq","imooc_arivn_4");
                      // });



                      #（3）、直接使用where()和链式的其他方法，比如 find()、field()  :查询的表的主键id值为1的记录

                       // $res = User::where("id","ELT",10)
                       // ->field("id,username")
                       // ->find();



                      #（4）、在方法(2)的基础上修改：多加一个field()方法

                      // $res = User::get(function($query){
                      //     $query->where("username","eq","imooc_arivn_4")
                      //     ->field("id, username");
                      // });



                      #(5)、使用all()同时返回多条数据（多个对象）

                         #①传递字符串

                         //$res = User::all("1,2,3");   //返回主键id分别为1，2，3 的数据（也是对象）
                                                      //注意： User::all("1,2,3") 相当于  User::all([1,2,3]) 
                         //  foreach($res as $val){
                         //     dump($val->toArray());
                         // }


                         #②传递函数
                         // $res = User::all(function($query){

                         //  $query->where("id","<","5")
                         //  ->field("id,username");
                         // });   //返回主键id分别为1，2，3 的数据（也是对象）
                                                      //注意： User::all("1,2,3") 相当于  User::all([1,2,3]) 
                         //  foreach($res as $val){
                         //     dump($val->toArray());
                         // } 
                   


                       #(6)返回多条数据(即多个对象):直接使用where()、select()

                           // $res = User::where("id",">","15")
                           // ->field("id username,email")
                           // ->limit(3)
                           // ->order("id DESC")
                           // ->select();

                           // foreach($res as $val){
                           //     dump($val->toArray());
                           // }



                        #(7）模型model获取某个字段的值用的方法: value()

                           //  $res = User::where("id",10)->value("email");
                           //  dump($res);



                        #(8) 获取多个字段或者说某个字段列的数据的方法： column()

                           // $res = User::column("email");  //返回一个数组
                           // $res = User::column("email","username");//第一个参数是设置数组的值，第二个参数是设置数组的下标 
                           // dump($res);

                      //$res = $res->toArray();  //将获取筛选的所有数据转为数组形式
                       dump($res);
                             
                 }

            }






-------------------------------------------------------------------------------------------------------------------------------------------


 3-3 使用模型添加数据 (13:52)

        在app\index\model目录下创建 User.php

        这里的 User类 仅仅只是继承了 Model类， 没有其他内容，不过即可以使用 Model类的方法

               app\index\model\User.php 内容： 

					<?php

					 namespace app\index\model;

					 use think\Model;

					 class User extends Model{

					     # 命名 imooc_user -> User.php User
					 	 #  imooc_user_info -> UserInfo.php UserInfo					 	

					 }
					?>




############## Thinkphp 5.0 的模型 3-3 使用模型添加数据 (13:52) ###############################

           //添加一条表数据，相当于我们创建一个模型对象，去插入到数据库表中

            namespace app\index\controller;

            use think\Controller;

            use app\index\model\User;

            class Index{

                  public  function index(){   

                #1、 model模型的create()静态方法

                     # 演示1
                       #POST
                       //当create()的第二个参数为true时，表示排除掉数据库中不存在的字段。 

                       // $res = User::create([
 
                       //    'username' => 'imooc',
                       //    'password' => md5('(imooc)'),
                       //    'email' => "imooc@qq.com",
                       //    'num' => 100,
                       //    'demo' => 213  //'demo'字段是我们数据库表中不存在的字段，若是这样子直接写去插入，会报错。

                       // ],true);  // 排除掉不存在的字段，我们就需要设置第二个参数为true。


                     # 演示2
                        //当create()的第二个参数为数组时， 数组的值表示是我们要插入数据的字段。
                        //['username','email'] 表示 仅仅只插入这两个字段‘username’ 和 ‘email’的数据

                         // $res = User::create([
   
                         //    'username' => 'imooc',
                         //    'password' => md5('(imooc)'),
                         //    'email' => "imooc@qq.com",
                         //    'num' => 100,
                         //    'demo' => 213  
                         // ],['username','email']);  

                         // dump($res->id);  //只打印获取自增id字段
                         //dump($res);


                #2、 model模型的save()静态方法: 该方法需要我们先实例化模型对象

                     #演示1

                     //先实例化一个model,再使用save()去添加数据

                     // $userModel = new User;
                     // $userModel->username = "1095654362";
                     // $userModel->email = "1095654362@qq.com";
                     // $userModel->password = md5('1095654362');
                     // $userModel->save();


                    #演示2 ：  直接给save()传一个数组参数

                     //先实例化一个model,再使用save()去添加数据

                     // $userModel = new User;
                     // $res = $userModel->save([

                     //      'username' => '10111111',
                     //      'password' => md5('1095654362'),
                     //       'email' => "1095654362@qq.com"
                     // ]);


                    #演示3 ：  如果传递了一个不存在的字段作为参数，可以使用 allowField进行过滤

                       //先实例化一个model,再使用save()去添加数据,

                       //当添加了一个数据库表不存在的字段，可以使用allowField进行过滤

                       // allowField(true) 表示过滤数据库表不存在的字段的参数

                       // allowField(['username','email']);表示 仅仅只插入这两个字段‘username’ 和 ‘email’的数据

                     $userModel = new User;
                     $res = $userModel->allowField(['username','email'])
                         ->save([
                                'username' => '10111111',
                                'password' => md5('1095654362'),
                                 'email' => "1095654362@qq.com",
                                 'demo' => 1233
                           ]);

                      dump($res);  //返回的是 被影响的行数值


                #3、 model模型的saveAll()静态方法: 该方法需要我们先实例化模型对象

                    $userModel = new User;
                     $res = $userModel
                         ->saveAll([
                                ['email' => "1111111@qq.com"],
                                 ['email' => "2222222@qq.com"]
                           ]);

                     //dumo($res); $res : 返回的是一个数组，保存着两个对象
                    foreach($res as $val){
                          dump($val->toArray());  //返回的是 被影响的行数值   
                    }

                 }
            }



            #注意：
                #save() 返回的是被影响的行数， 而使用 create() 和 saveAll() 返回的是model对象或者是 一个保存的对象集的数组，
                
                #所以需要使用foreach进行遍历打印

                #如果需要过滤不存在的字段，可以使用allowField() 或者给create()添加第二个参数







-------------------------------------------------------------------------------------------------------------------------------------------


 3-4 使用模型更新数据 (13:14)


############## Thinkphp 5.0 的模型 3-4 使用模型更新数据 (13:14) ###############################


            // namespace app\index\controller;

            // use think\Controller;
            // use app\index\model\User;
            // class Index{

            //       public  function index(){   

                    #开始演示更新数据前，先把之前表所有的数据都删除掉，并且添加一些新的数据
                    // $data = [];
                    // for($i=1; $i<21; $i++){
                    //     $data[] = [
                    //         'username' =>"imooc_{$i}",
                    //         'email' => "imooc_{$i}@qq.com",
                    //         'password' => md5("imooc_{$i}"),
                    //         'num' => $i+100
                    //     ];
                    // }
                    // $userModel = new User();
                    // $res = $userModel->saveAll($data);
                    
                    // foreach($res as $val){
                    //    dump($val->toArray());
                    // }

                    //注意： 以上代码执行完一次后将其注释掉，避免重复插入数据


                    #1、model模型中 update()方法

                     #演示1： 更新一个简单或者不需要验证数据的时候

                       //当更新的字段中存在主键id时，则不需要编写where()
                       // $res = User::update([
                       //    'id' => 1,
                       //    'username' => '1095654362'
                       // ]);   


                      #演示2： 传递第二个参数，作为where条件

                           // //① 第二个参数为数组时
                           // // 更新id为2 的记录的 username 字段修改成 ‘1095654362’
                           // $res = User::update([
                           //    'username' => '1095654362'
                           // ], ['id'=>2]);   
                           // dump($res);


                           //② 第二个参数为函数时
                           // 更新id为2 的记录的 username 字段修改成 ‘1095654362’
                               // $res = User::update([
                               //    'username' => '1095654362'

                               // ], function($query){

                               //    $query->where("id","LT",5);
                               // });   
                               // dump($res);


                      #演示3： 模型model直接使用where()方法 和 updata方法

                           // $res = User::where("id","<","6")
                           // ->update([
                           //     'username' => "1095654362"
                           // ]);

                           // dump($res);   //这里返回的是被影响的行数，建议使用这种方法


                      #演示4： 使用模型model的get()获取一条数据(一个对象)，修改其字段(即属性)后，用save()保存在数据库中

                          // $userModel = User::get(1);
                          // $userModel->username = '123';
                          // $userModel->email = '123@qq.com';
                          // $res = $userModel->save();
                          
                          // dump($res);   //这里返回的是被影响的行数，建议使用这种方法


                       #演示5： 使用 new User() 的方式 ,

                          //这里的save()需要设置第二个参数，不然会变成新增数据操作

                          // #①、save()第二个参数为数组的情况

                                // //这里save()传递第二个['id',5] 进行选取数据库表中 id=5 的 记录进行修改

                                // $userModel = new User();
                                // $res = $userModel->save([
                                //       'username'=> "123445677"
                                // ],['id'=>5]);
                                //dump($res);   //这里返回的是被影响的行数，建议使用这种方法

 
                          // #①、save()第二个参数为函数的情况

                               //  $userModel = new User();
                               //  $res = $userModel->save([
                               //        'username'=> "123445677"
                               //  ],function($query){
                               //      $query->where('id','<',10);

                               //  });
                          
                               // dump($res);   //这里返回的是被影响的行数，建议使用这种方法

                      #演示6： 批量更新数据

                             // $userModel = new User;

                             // $res = $userModel -> saveAll([
                             //   ['id'=>1,'username'=>1],
                             //   ['id'=>2,'username'=>2]
                             // ]);

                             // dump($res);  //返回的是一个保存对象的数组。


                      # 总结： 我们一般使用返回值为”被影响行数“ 的方法， 而不采用返回”保存对象的数组“的方法。

                               //所以一般更新不推荐使用 update 静态方法和 saveAll 推荐使用 where+update 或者 save+（where条件 or 闭包函数）
            //      }
            // }



额外笔记：

           model层里面写的是对数据库进行操作的方法已经从think\model继承了那些方法，现在是在controller层进行调用实现。

           # 总结： 我们一般使用返回值为”被影响行数“ 的方法， 而不采用返回”保存对象的数组“的方法。

           //所以一般更新不推荐使用 update 静态方法和 saveAll 推荐使用 where+update 或者 save+（where条件 or 闭包函数）

-------------------------------------------------------------------------------------------------------------------------------------------


 3-5 使用模型删除数据 (05:09)

############## Thinkphp 5.0 的模型 3-4 使用模型更新数据 (13:14) ###############################


            namespace app\index\controller;

            use think\Controller;
            use app\index\model\User;
            class Index{

                  public  function index(){   

                    #1、使用 model模型中的 destroy()方法  : 返回值是被影响的行数

                       #演示1：  删除主键为1 的记录
                           // $res = User::destroy(1);
                           // dump($res);


                       #演示2：  给destroy传递一个数组
                           // $res = User::destroy(['id' => '2']);
                           // dump($res);

                       #演示3：  给destroy传递一个闭包函数
                           // $res = User::destroy(function($query){
                           //     $query->where('id','<','5');
                           // });
                           // dump($res);


                      #2、实例化模型，并且使用delete()方法 : 返回值是被影响的行数


                         #演示1： 删除 主键值为7 的数据

                              // $username = User::get(7);
                              // $res = $username->delete();

                              // dump($res);


                         #演示2： 删除 主键值为7 的数据

                              // $username = User::get(7);
                              // $res = $username->delete();

                              // dump($res);



                     #3、使用 where() + delete() 方法 : 返回值是被影响的行数
                          

                          //删除 id<10 的数据 
                            // $res = User::where('id', '<', 10);
                            // -> delete();


                          //如果想删除数据库表的全部数据，可以传递一个 “1=1” 的恒等条件
                             // $res = User::where("1=1")
                             // ->delete();
                             // dump($res);


                 }
            }




-------------------------------------------------------------------------------------------------------------------------------------------


 3-6 模型聚合操作 (07:56)


############## Thinkphp 5.0 的模型 3-6 模型聚合操作 (07:56) ###############################


            namespace app\index\controller;

            use think\Controller;
            use app\index\model\User;
            class Index{

                  public  function index(){   

                    #开始演示更新数据前，先把之前表所有的数据都删除掉，并且添加一些新的数据

                    // $data = [];
                    // for($i=1; $i<11; $i++){
                    //     $data[] = [
                    //         'username' =>"imooc_{$i}",
                    //         'email' => "imooc_{$i}@qq.com",
                    //         'password' => md5("imooc_{$i}"),
                    //         'num' => $i+100
                    //     ];
                    // }
                    // $userModel = new User();
                    // $res = $userModel->saveAll($data);
                   


                    #1、 count() :返回数据库表的记录数


                          //演示1：返回 user表的总记录数
                            //$res = User::count();
                            // dump($res);


                          //演示2：返回 id>5 的记录数
                             // $res = User::where("id", ">", "5")
                             // ->count();
                             // dump($res);



                     #2、 max() :返回数据库表的某个字段的最大值


                          //演示1：返回 user表的‘num’字段的最大值

                            //$res = User::max('num');
                               // dump($res);



                          //演示2：返回 id<5 的所有记录中的‘num’ 字段的最大值

                             // $res = User::where("id", "<", "5")
                             // ->max('num');
                             // dump($res);



                    #3、 sum() :返回数据库表的某个字段的所有值的总和


                          //演示1：返回 user表的‘num’字段的总和

                            // $res = User::sum('num');
                            //    dump($res);



                          //演示2：返回 id<5 的所有记录中的‘num’ 字段的总和

                             // $res = User::where("id", "<", "5")
                             // ->sum('num');
                             // dump($res);
 


                         //演示3：返回 id<5 的所有记录中的‘num’ 字段的总和（和演示2结果一样，方式不同）

                             // $res = User::where("id", "<", "5")
                             // ->max('num');
                             // $res = User::sum('num');
                             // dump($res);



                    #4、 avg() :返回数据库表的某个字段的所有值的平均值


                          //演示1：返回 user表的‘num’字段的平均值

                            // $res = User::avg('num');
                            //    dump($res);



                          //演示2：返回 id<5 的所有记录中的‘num’ 字段的平均值

                             // $res = User::where("id", "<", "5");
                             // ->avg('num');
                             // dump($res);



                         //演示3：返回 id<5 的所有记录中的‘num’ 字段的平均值（和演示2结果一样，方式不同）

                             // $res = User::where("id", "<", "5")
                             // ->max('num');
                             // $res = User::avg('num');
                             // dump($res);



                    #5、 min() :返回数据库表的某个字段的最小值



                          //演示1：返回 user表的‘num’字段的最小值

                            // $res = User::min('num');
                            //    dump($res);



                          //演示2：返回 id>5 的所有记录中的‘num’ 字段的最小值

                             $res = User::where("id", ">", "5")
                             ->min('num');
                             dump($res);
                 }
            }



总结：

        count     User::count();   获取数据总条数     

        max       User::max('字段名')   获取指定字段值的最大值

        sum       User::sum('字段名')   获取指定字段值的总和

        avg       User::avg('字段名')   获取指定字段值的平均值 

        min       User::min('字段名') 获取指定字段值的最小值 


        都可以和where条件合作




额外笔记：


         1、为什么使用循环的时候包含花括号的变量要用双引号？

            用单引号不能解析{$i}是为什么？

                         单引号不会解析变量，双引号才解析变量


-------------------------------------------------------------------------------------------------------------------------------------------


 3-7 模型获取器 (06:21)


         获取器的作用： 在获取数据的字段值后自动进行处理

         #前提： 
                我们之所以需要用到模型获取器，是因为我们在开发过程中，在数据库表中，有时候我们类似于 性别sex 的字段一般存的数据不是 字符‘男’和字符‘女’，而是保存 ‘0’和‘1’， ‘0’ 代表 ‘男’， ‘女’ 表示1。

                而模型获取器的作用就是 我们在 取到 ‘0’ 数据时可以直接获取 到‘男’这个字符值，在保存 ‘男‘值时， 在保存到数据库表中时可以自动转化为’0‘值，保存到数据库表中。





        1、演示： 在数据库表中一般使用0，1,2 表示 性别字段sex ，实际应用中想要获取用舻男e是 字符‘男’ 和 字符 ‘女’


              ①、首先需要在模型model\User.php中添加 内容：  添加 getSexAttr()方法

					<?php

					 namespace app\index\model;

					 use think\Model;

					 class User extends Model{

					     # 命名 imooc_user -> User.php User
					 	 #      imooc_user_info -> UserInfo.php UserInfo					 	
                                            
					     public function getSexAttr($val){

					          switch ($val) {

					          	case '1':
					          		return "男";
					          		break;
					          	
					            case '2':
					          		return "女";
					          		break;

					          	default:
					          		return "未知";
					          		break;
					          }
					     }
					 }
					?>

               ②、控制器中的代码：

                    namespace app\index\controller;

                    use think\Controller;
                    use app\index\model\User;
                    class Index{

                          public  function index(){  

                             # 在数据库表imooc_user表中添加一个 ‘sex’ 字段来进行演示

                               $res = User::get(2);

                               //echo $res->sex;

                               // dump($res->toArray());   //可利用toArray获取修改后的数据

                               // dump($res->getData());   //可利用getData获取原始（未修改）的数据  

                         }
                    }	


                  打印结果：
 
                     echo $res->sex; ---》 对应：

                                          男


                     dump($res->toArray()); ---》 对应：


                        array (size=7)
                          'id' => int 2
                          'username' => string 'imooc_2' (length=7)
                          'password' => string '4e5375a4aedfb4044b84546e3a7e547d' (length=32)
                          'email' => string 'imooc_2@qq.com' (length=14)
                          'num' => int 102
                          'group' => int 0
                          'sex' => string '男' (length=3)

                         //  这里的'sex'值已经被修改成 ‘男’


                     dump($res->toArray()); ---》  对应：

                          array (size=7)
                              'id' => int 2
                              'username' => string 'imooc_2' (length=7)
                              'password' => string '4e5375a4aedfb4044b84546e3a7e547d' (length=32)
                              'email' => string 'imooc_2@qq.com' (length=14)
                              'num' => int 102
                              'group' => int 0
                              'sex' => int 1


                            //  这里的'sex'值还是保持原来的 ‘1’ 



          2、演示：获取器的作用是在获取数据的字段值后自动进行处理，

   
             例如，我们需要对状态值进行转换，可以使用：


                        class User extends Model 
                        {
                            public function getStatusAttr($value)
                            {
                                $status = [-1=>'删除',0=>'禁用',1=>'正常',2=>'待审核'];
                                return $status[$value];
                            }
                        }



                   数据表的字段会自动转换为驼峰法，一般status字段的值采用数值类型，我们可以通过获取器定义，自动转换为字符串描述。


                          $user = User::get(1);

                          echo $user->status; // 例如输出“正常”



                   获取器还可以定义数据表中不存在的字段，例如：

                        class User extends Model 
                        {
                            public function getStatusTextAttr($value,$data)
                            {
                                $status = [-1=>'删除',0=>'禁用',1=>'正常',2=>'待审核'];
                                return $status[$data['status']];
                            }
                        }

                   获取器方法的第二个参数传入的是当前的所有数据数组。
 
 
                   我们就可以直接使用status_text字段的值了，例如：


                       $user = User::get(1);

                       echo $user->status_text; // 例如输出“正常”


                   获取器只有当获取某个数据属性的时候自动触发，如果你要获取包含获取器处理的全部数据属性的话，可以使用下面的方法：

                       $user = User::get(1);

                       //获取全部获取器数据

                       dump($user->toArray());



                   获取原始数据

                     如果你定义了获取器的情况下，希望获取数据表中的原始数据，可以使用：

                            $user = User::get(1);
                            // 通过获取器获取字段

                            echo $user->status;
                            // 获取原始字段数据

                            echo $user->getData('status');
                            // 获取全部原始数据

                            dump($user->getData());



  ===================================================================================


总结：

           成员方法(get字段名Attr)[字段名首字母大写]

           在model中使用   后面有代码

           在controller中use下model中的类(该类需继承model类)

           后利用各种查询方法获取数据值

           可利用toArray获取改后数据

           可利用getData获取改前数据



额外笔记：

mysql的基本数据类型里几个int如下：


类型              大小     范围（有符号）    范围（无符号）                                                          用途

TINYINT          1字节     (-128，127) (0，255)                                                                      小整数值

SMALLINT         2 字节    (-32 768，32 767) (0，65 535)                                                             大整数值

MEDIUMINT        3 字节    (-8 388 608，8 388 607) (0，16 777 215)                                                   大整数值

INT或INTEGER     4 字节    (-2 147 483 648，2 147 483 647) (0，4 294 967 295)                                        大整数值

BIGINT          8 字节      (-9 233 372 036 854 775 808，9 223 372 036 854 775 807) (0，18 446 744 073 709 551 615)  极大整数值




-------------------------------------------------------------------------------------------------------------------------------------------


 3-8 模型修改器-+自动完成 (11:51)

       修改器的作用：可以在数据赋值的时候自动进行转换处理，类似于密码password这个数据，一般我们不会直接保存在数据库中，而是要经过加密才能保密在数据库中。

      模型修改器的作用和 模型获取器的作用 相反。

      1、模型修改器的演示：

 
              ①、首先需要在模型model\User.php中添加 内容：  添加 setPasswordAttr()方法（即模型修改器）

	           //数据修改器,在进行插入操作的时候，或者在数据进行插入操作的时候，会调用该方法来进行数据的改变再插入到数据库表中。

			//数据修改器的第一种写法： 只有一个参数
			       
		                 public function setPasswordAttr($val){
		                      return md5($val);
		                 }



		        //数据修改器的第二种写法：  两个参数

                        //$data 表示我们即将要插入的所有数据。 

		                public function setPasswordAttr($val,$data){

                                    return md5($val . $data['email']);  //表示我们的密码先连接邮箱组成新的字符串，然后再进行加密。
		                 }


               ②、控制器中的代码： 这里的密码在插入时会通过 模型修改器来进行加密。

                    namespace app\index\controller;

                    use think\Controller;
                    use app\index\model\User;
                    class Index{

                          public  function index(){  

                              $res = User::create([
                                 'username' => 'imooc',
                                 'sex' => 0,
                                 'email' => 'imooc@qq.com',
                                 'password' => 'imooc',
                                 'num' => 1
                              ]);

                              dump($res);

                         }
                    }


      2、自动完成

           model\User.php 的 内容： 

		<?php

		 namespace app\index\model;

		 use think\Model;

		 class User extends Model{

			# 命名 imooc_user -> User.php User
			#      imooc_user_info -> UserInfo.php UserInfo


		################################################################

		  #自动完成

		     //如果我们想使用自动完成，首先我们需要声明一个数组$auto、或者数组$insert、或者数组$update等，数组里面的内容就是我们要完成的字段，类似这里’time‘字段、’time_insert‘字段、’time_update‘字段

		     #演示1：

	               //数组$auto 是在数组添加、更新等变化都会完成自动完成的操作，它定义的方法和我们的模型修改器是一样的

		       //'time' 对应的模型修改器是 ’setTimeAttr()‘, 对应的数据库表的字段为’time‘

			         protected $auto = ['time'];

			         //time对应的模型修改器 setTimeAttr()

			          public function setTimeAttr(){

			              return time();   // time()函数 返回的是时间戳。
			          }


		    #演示2

		      //数组$insert  ：$insert 表示只在 数据插入新增的时候有效。

		      // 'time_insert' 对应的模型修改器是 ’setTimeInsertAttr()‘, 对应的数据库表的字段为’time_insert‘
		 
			         protected $insert = [

			                'time_insert' 
			          ];

		       //time_insert对应的模型修改器 setTimeInsertAttr

			   public function setTimeInsertAttr(){

			        return time();   // time()函数 返回的是时间戳。
			     }


		    #演示3
			                           
                      //数组$update  ：$update 表示只在 数据更新的时候有效,会对数据进行改变。所以在数据插入新增的时候，这个修改器是不会执行的，所以数据库表中的time_update字段依然不会修改

		      // 'time_update' 对应的模型修改器是 setTimeUpdateAttr()‘, 对应的数据库表的字段为’time_update‘
		 

			        protected $update = [

			                    'time_update' 
			          ];

		      //time_update对应的模型修改器 setTimeUpdateAttr

			         public function setTimeUpdateAttr(){

			             return time();   // time()函数 返回的是时间戳。

			        }
		                      


		################################################################

		 }
		?>


               控制器index.php 中测试

                    namespace app\index\controller;

                    use think\Controller;
                    use app\index\model\User;
                    class Index{

                          public  function index(){  

                              // $res = User::create([
                              //    'username' => 'imooc',
                              //    'sex' => 0,
                              //    'email' => 'imooc@qq.com',
                              //    'password' => 'imooc',
                              //    'num' => 1
                              // ]);
                              //dump($res);


                              //测试自动完成 'time_update' 对应的模型修改器是 setTimeUpdateAttr()‘ ，在数据更新的过程中有效

                                  $userModel = User::get(15);

                                  $userModel->sex = 1;

                                  $res = $userModel->save(); 

                                  dump($res);

                                  //执行以上代码时， 数据库表中的time_update字段更新了数据， 说明在有数据更新时，自动完成的模型修改器setTimeUpdateAttr 会启动。

                         }
                    }



总结：

set+字段名+Attribute

auto （新增及更新的时候自动完成的属性数组）

insert（仅新增的时候自动完成的属性数组）

update（仅更新的时候自动完成的属性数组）



-------------------------------------------------------------------------------------------------------------------------------------------


 3-9 模型时间戳+软删除 (18:53)

        

        1、定义：

            (1)、模型时间戳的作用： 
                                  我们对数据进行新增或者更新操作的时候，往往需要记录我们对数据的更新时间和插入时间，也就是最后一次的更新时间，虽然我们可以使用 “自动完成”的方式来完成这个的功能。但是我们大多数数据库都会有这样的字段，要是我们每个字段都去编写这样的‘自动完成’的功能，那么我们代码就会变得很庸冗，我们实现起来也不是很方便。所以 thinkphp 的model类为我们提供了时间戳的功能，它会自动写入记录我们创建和更新的时间戳字段

           （2）、软删除：
                         在我们对数据进行删除的操作的时候，我们往往不会对这条数据在我们的数据库中真正的删除。而是将它的某个字段设置成为一个特定的值，代表这个字段已经被删除。

                         在实际项目中，对数据频繁使用删除操作会导致性能问题，软删除的作用就是把数据加上删除标记，而不是真正的删除，同时也便于需要的时候进行数据的恢复。

                         要使用软删除功能，需要引入 SoftDelete trait，例如 User 模型按照下面的定义就可以使用软删除功能


       2、模型时间戳的演示

           (1)、首先我们需要更新应用配置 数据库的配置文件database.php：

                  系统支持自动写入创建和更新的时间戳字段，有两种方式配置支持。


                     第一种方式，是在数据库配置文件中添加全局设置：

                                // 开启自动写入时间戳字段

                                    'auto_timestamp' => true,

                         注意：在我们很多的时候，我们并不是所有的数据库表都有时间戳或者有创建时间’create_time‘ 和更新时间 ’update_time‘，所以一般不建议在数据库的配置文件database.php 直接修改  'auto_timestamp' => true, 因为这样修改的话，要是你的数据库表中不存在创建时间’create_time‘ 和更新时间 ’update_time‘，那么程序就有可能会报错。



                     第二种是直接在单独的模型类里面设置：

                                    protected $autoWriteTimestamp = true;


                 注意：

                       ①、如果这两个地方设置为true，默认识别为整型 int 类型，如果你的时间字段不是 int 类型的话，例如使用 datetime 类型的话，可以这样设置：

                             // 开启自动写入时间戳字段

                                       'auto_timestamp' => 'datetime',
                                     或者
                                        protected $autoWriteTimestamp = 'datetime';


                      字段名默认创建时间字段为 create_time ，更新时间字段为 update_time ，支持的字段类型包括 timestamp/datetime/int 

                      写入数据的时候，系统会自动写入 create_time 和 update_time 字段，而不需要定义修改器，例如：

                                        $user = new User();

                                        $user->name = 'THINKPHP';

                                        $user->save();

                                        echo $user->create_time; // 输出类似 2016-10-12 14:20:10

                                        echo $user->update_time; // 输出类似 2016-10-12 14:20:10


                       V5.0.5+ 版本开始，时间字段输出的时候会自动进行格式转换，如果不希望自动格式化输出，可以把数据库配置文件的 datetime_format 参数值改为 false （V5.0.6+ 版本支持，之前版本可以使用类型转换方式关闭自动格式化）



                       ②、如果你的数据表字段不是默认值的话，可以按照下面的方式定义：

                                  class User extends Model
                                   {
                                      // 定义时间戳字段名
                                          protected $createTime = 'create_at';

                                          protected $updateTime = 'update_at';
                                    }

                             解析：如果你的数据表字段不是默认值，而且没有进行以上配置的话，插入数据时

                                     会报错：数据表字段不存在:[update_time]


                      下面是修改字段后的输出代码：

                                  $user = new User();

                                  $user->name = 'THINKPHP';

                                  $user->save();

                                  echo $user->create_at; // 输出类似 2016-10-12 14:20:10

                                  echo $user->update_at; // 输出类似 2016-10-12 14:20:10



                       ③、如果你只需要使用 create_time 字段而不需要自动写入 update_time ，则可以单独设置关闭某个字段，例如：

                                  class User extends Model
                                  {
                                        // 关闭自动写入update_time字段

                                              protected $updateTime = false;
                                  }



                       ④、如果不需要任何自动写入的时间戳字段的话，可以关闭时间戳自动写入功能，设置如下：

                                  class User extends Model
                                  {
                                         // 关闭自动写入时间戳

                                             protected $autoWriteTimestamp = false;
                                   }



                       ⑤、如果是关闭全局的自动时间写入，则可以使用：

                                  // 关闭全局自动写入时间字段

                                        'auto_timestamp' => false,



          (2)、

             ①、model\User.php 的 内容： 

		<?php

		 namespace app\index\model;

		 use think\Model;

		 class User extends Model{

			# 命名 imooc_user -> User.php User
			#      imooc_user_info -> UserInfo.php UserInfo

################################################################

                  #直接在单独的模型类里面设置 : 开起单个模型的时间戳
 
                      protected $autoWriteTimestamp = true;

                      //定义时间戳字段名

                      protected $createTime = false; //如果你只需要使用 update_time 字段而不需要自动写入create_time ，则可以单独设置关闭某个字段,使用 "$createTime = 'false'"

                      protected $updateTime = 'update_at';


################################################################

		 }
		?>



             ②、控制器index.php 中测试

                    namespace app\index\controller;

                    use think\Controller;
                    use app\index\model\User;
                    class Index{

                          public  function index(){  

                            #创建新的数据库表有，因为之前测试的那个数据库表的字段太多，不方便我们测试。
                            #如果我们要记录数据的创建时间和更新时间，我们需要创建两个字段 ’create_time‘ 和 ’update_time‘

                              $res = User::create([
                                 'name' => 'imooc',
                                 'password' => md5('imooc')
                              ]);
                              dump($res);

                               // $userModel = User::get(1);
                               // $userModel->name = "imooc_arvin";
                               // $res = $userModel->save();
                               // dump($res);


                              //当我们执行以上代码对数据库进行插入数据时，系统会自动为数据库表的两个字段 ’create_time‘ 和 ’update_time‘进行数据插入或者更新。
                         }
                    }


       3、软删除

           （1）如何使用软删除

                 ①、数据库表中新增字段：

                       #如果我们想使用软删除，我们需要给数据库表新增一个字段：delete_time, 注意这个字段是允许为null的，但delete为null时，表示这条数据没有被删除。

                 ②、  在模型User.php中

                        引入SoftDelete  ：use traits\model\SoftDelete;  

                        然后在类class中 使用SoftDelete ：  use SoftDelete;   
                         

                 ③、在控制器index.php中直接使用 destroy(()方法：

                           $res = User::destroy((1);  //传递一个主键值就可以对数据进行删除。

                           dump($res);

                解析： 这里对数据进行删除时，当我们去数据库进行查询时，这个数据依然还是存在的，但是 delete_time 字段多了一个时间戳的数据。
                              
                        并且 当我们再用get(1):

                                $res = User::get(1);
                                dump($res);

                        去获取该记录时，返回值是 null 

                        虽然我们数据库中有这条数据，但是我们使用get（）find（）是获取不到的。

                        如果我们需要获取到已经软删除的数据时：使用以下方法

                                 $res =  User::withTrashed(true)->find(1);

                                 dump($res->getData()); //getData() 获取原始数据


                      另一种情况： 我们被删除的数据都在垃圾箱中，我们现在想在垃圾箱中获取所有被删除的数据

                                 $res = User::onlyTrashed()->select();  //返回多条记录，使用select();

                                  foreach($res as $val){

                                      dump($val->getData());
                                  }


           （2）如果我们不希望使用 delete_time 来进行软删除的记录,而是使用字段“delete_at”

                可以在User模型中定义：
                                class User extends Model
                                   {                                    
                                          protected $delete_time  = 'delete_at';
                                    }


                 然后在控制器index.php中进行删除                   

                    $res = User::destroy(2);  //传递一个主键值就可以对数据进行删除。 返回值是int(1) ：表示有一条数据被删除;


                执行以上代码，数据库中的 “delete_at” 字段也是会被更新，有数据被保存，说明 id=2 的数据有被删除。



           （3）#另一种情况： 我们被删除的数据都在垃圾箱中，我们现在只想在垃圾箱中获取所有被删除的数据

                                
                                  // $res = User::onlyTrashed()->select();  //返回多条记录，使用select();

                                  // foreach($res as $val){

                                  //     dump($val->getData());
                                  // }



            （4）#当我们使用了SoftDelete，我们就无法对数据进行真正的删除操作，如果我们想对数据进行真正的删除时，

                 
                   方法一： 可以给destroy()传递第二参数为true。

                                    $res = User::destroy(3,true);

                                    dump($res);

                    //执行以上代码，数据就会被真正地删除，不会保留在数据库中。



                   方法二： 使用delete()。

                                  $user = User::get(4);

                                  $res = $user->delete(true);

                                   dump($res);

                                    //执行以上代码，数据就会被真正地删除，不会保留在数据库中。
                   


       4、thinkphp手册中的软删除

             在实际项目中，对数据频繁使用删除操作会导致性能问题，软删除的作用就是把数据加上删除标记，而不是真正的删除，同时也便于需要的时候进行数据的恢复。

            （1）、要使用软删除功能，需要引入 SoftDelete trait，例如 User 模型按照下面的定义就可以使用软删除功能

                        namespace app\index\model;

                        use think\Model;

                        use traits\model\SoftDelete;

                        class User extends Model
                        {
                                  use SoftDelete;
                                  protected $deleteTime = 'delete_time';
                        }


                     注意：5.0.2 版本之前 deleteTime 属性必须使用 static 定义。
                      
                     deleteTime 属性用于定义你的软删除标记字段， ThinkPHP5 的软删除功能使用时间戳类型（数据表默认值为 Null ），用于记录数据的删除时间。

                     可以用类型转换指定软删除字段的类型，建议数据表的所有时间字段统一一种类型。


            （2）、定义好模型后，我们就可以使用：

                            // 软删除
                            User::destroy(1);

                            // 真实删除
                            User::destroy(1,true);

                            // 软删除
                            $user = User::get(1);
                            $user->delete();

                            // 真实删除
                            $user->delete(true);


            （3）、默认情况下查询的数据不包含软删除数据，如果需要包含软删除的数据，可以使用下面的方式查询：
   
                            User::withTrashed()->find();

                            User::withTrashed()->select();


                    如果仅仅需要查询软删除的数据，可以使用：

                            User::onlyTrashed()->find();

                            User::onlyTrashed()->select();
  

                    如果你的模型定义了 base 基础查询，请确保添加软删除的基础查询条件。



-------------------------------------------------------------------------------------------------------------------------------------------




第4章 课程总结

本章节第本门课程的重点、难点知识进行回顾

 4-1 课程总结 (02:21)


      关于数据库增删改查的操作时，什么时候需要实例化 模型呢？

             不实例化用的是静态方法，实例化之后用的是类中的非静态方法，实现功能大致上差不多，但是如果同时操作很多对象，需要区分各个实例，那就需要实例化了。







-------------------------------------------------------------------------------------------------------------------------------------------

主颜色：#0087ffc4



博客数据库

用户表

CREATE TABLE `think_blog_db`.`blog_user` (
  `user_id` INT UNSIGNED NOT NULL AUTO_INCREMENT,
  `user_name` VARCHAR(45) NOT NULL,
  `user_password` VARCHAR(255) NOT NULL,
  `user_phone` VARCHAR(45) NULL,
  `user_sex` TINYINT UNSIGNED NOT NULL DEFAULT 0 COMMENT '用户性别： 0 表示‘未知’   1表示‘男’  2表示‘女’',
  `user_create_time` TIMESTAMP NOT NULL COMMENT '用户的注册时间',
  `user_update_time` TIMESTAMP NULL COMMENT '用户更改信息的时间',
  `user_create_ip` VARCHAR(45) NULL COMMENT '用户注册时所用的ip',
  `user_email` VARCHAR(64) NOT NULL,
  `user_last_login_ip` VARCHAR(45) NULL COMMENT '用户上一次登录的ip',
  `user_image_url` VARCHAR(255) NULL COMMENT '用户头像存储路径',
  `user_rank` TINYINT UNSIGNED NULL DEFAULT 0 COMMENT '用户等级： 0表示游客  1表示已登录的用户  2表示管理员',
  PRIMARY KEY (`user_id`, `user_create_time`))
ENGINE = MyISAM
DEFAULT CHARACTER SET = utf8
COLLATE = utf8_general_ci;


文章表

CREATE TABLE `think_blog_db`.`blog_article` (
  `article_id` INT UNSIGNED NOT NULL AUTO_INCREMENT,
  `article_title` VARCHAR(100) NOT NULL COMMENT '文章标题',
  `article_content` LONGTEXT NOT NULL COMMENT '文章内容',
  `article_user_id` INT UNSIGNED NULL COMMENT '作者id',
  `article_create_time` INT NULL COMMENT '文章的添加时间',
  `article_update_time` INT NULL COMMENT '文章更新时间',
  `article_public_time` INT NULL COMMENT '文章发布时间',
  `article_click` INT UNSIGNED NOT NULL DEFAULT 0 COMMENT '文章点击量',
  `article_status` INT UNSIGNED NOT NULL DEFAULT 0 COMMENT '0:草稿  1：公开',
  `article_type1` VARCHAR(45) NULL COMMENT '文章类型1： 转载，原则，翻译',
  `article_type2` VARCHAR(45) NULL COMMENT '文章类型2： 数据库、后台、前端、互联网等等',
  `article_up` INT UNSIGNED NULL DEFAULT 0 COMMENT '是否置顶：  0为否，1为是',
  `article_tags` VARCHAR(100) NULL COMMENT '文章各种标签：java、php、c#等等',
  `article_coverimg_url` VARCHAR(200) NULL COMMENT '文章封面图片地址',
  `delete_time` INT(10) NULL DEFAULT NULL,
  `article_ip` VARCHAR(45) NULL COMMENT '文章最后添加、发布、更改时的ip地址',
  PRIMARY KEY (`article_id`))
ENGINE = MyISAM
DEFAULT CHARACTER SET = utf8
COLLATE = utf8_general_ci;




1095654362@qq.com

arvin517@163.com

qq邮箱授权码：iqnhbjaffnbujhfd



js定义模块：https://www.jianshu.com/p/5226bd9644b6









tab_bowen



add_unlock
add_lock





add_bw_type

add_bw_type2





search_bw_type

bowen_date

search_bw_title  


search_bw_starttime

search_bw_endtime













































